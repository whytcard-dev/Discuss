# WhytCard の一般的なスタイルガイド ## はじめに このドキュメントでは、WhytCard プロジェクトで使用されるすべての言語とテクノロジーに共通する一般的なコーディングスタイルとベストプラクティスを定義します。これらの標準は、コードベース全体の一貫性、保守性、品質を保証します。 ## 目次 1. [基本原則](#fundamental-principles) 2. [命名規則](#naming-conventions) 3. [フォーマット](#formatting) 4. [ドキュメント](#documentation) 5. [コード構造](#code-structure) 6. [言語固有のガイドライン](#language-specific-guidelines) 7. [バージョン管理](#version-control) ## 基本原則 ### 巧妙さよりも明快さ 巧妙で複雑な解決策よりも、常にコードの明快さを優先します。 - 理解しやすいコードを書く - 必要がない限り、わかりにくい言語機能は避ける - 簡潔さよりも読みやすさと保守性を優先する ### 一貫性 コードベース全体で一貫性を維持する: - プロジェクトで確立されたパターンに従う - 異なるスタイルやアプローチを混在させない - 既存のコードを変更する場合は、そのスタイルに合わせる ### DRY (Don&#39;t Repeat Yourself) 同じことを繰り返さないコードの重複: - 繰り返しコードを関数またはクラスに抽出します - 共通操作用の共有ユーティリティを作成します - 継承またはコンポジションを使用して動作を共有します ### KISS (Keep It Simple, Stupid) 複雑なソリューションよりもシンプルなソリューションを優先します: - 機能する最もシンプルなアプローチから始めます - 必要な場合にのみ複雑さを追加します - 複雑な問題をより単純な部分に分割します ### YAGNI (You Aren&#39;t Gonna Need It) 必要になるまで機能を追加しません: - 推測的な機能を避ける - 今必要なものだけを実装する - 事前にではなく、必要なときにリファクタリングします ## 命名規則 ### 一般的なルール - 名前は説明的で目的を伝える必要があります - 略語ではなく完全な単語を使用します (一般的なものを除く) - 既存の命名パターンと一貫性を保ちます ### 大文字と小文字のスタイル 各言語に適切な大文字と小文字のスタイルを使用します: - **camelCase**: JavaScript/TypeScript の変数と関数 - **PascalCase**: ほとんどの言語のクラス、React コンポーネント - **snake_case**: Python の変数と関数 - **ケバブケース**: HTML 要素、CSS クラス、ファイル名 - **UPPER_SNAKE_CASE**: ほとんどの言語の定数 ### 命名例 ```javascript // JavaScript const userProfile = { firstName: &#39;John&#39;, lastName: &#39;Doe&#39;, EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculateTotalPrice(items) { // 実装 } class UserManager { // 実装 } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculate_total_price(items): # 実装 pass class UserManager: # 実装 pass ``` ## フォーマット ### インデント - プロジェクト全体で一貫したインデントを使用します - JavaScript/TypeScript/HTML/CSSの場合: スペース2つ - Pythonの場合: スペース4つ (PEP 8) - タブとスペースを混在させないでください ### 行の長さ - ほとんどの言語で行を最大100文字に制限します - Pythonの場合は、PEP 8に従います (コードの場合は79文字、コメントの場合は72文字) - 言語に自然な方法で長い行を分割します ### スペース - 演算子の前後にスペースを使用します - カンマとセミコロン - 関数呼び出しと宣言で一貫したスペースを使用します ### 括弧とブロック - ほとんどの言語で同じ行に開き括弧を使用します (Python 関数とクラスを除く) - 単一行のブロックでも括弧を一貫して使用します - 閉じ括弧を開始行の先頭に揃えます ### 例 ```javascript // JavaScript function calculateDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculate_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Item 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Item 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Item 3&quot;, &quot;price&quot;: 30}, ] ``` ## ドキュメント ### コードコメント - コメントは「何」ではなく「なぜ」を説明するために使用します - 複雑なアルゴリズムやわかりにくい解決策についてはコメントします - コードの変更に合わせてコメントを更新します - 冗長または明らかなコメントは避けます ### 関数とメソッドのドキュメント すべての関数とメソッドについて、次の情報をドキュメント化します: - 目的の説明 - パラメーターとその型 - 戻り値と型 - スローされる可能性のある例外 - 複雑な関数の使用例 ### ファイルヘッダー 各ファイルの先頭に次の情報を含めます: - ファイルの目的の簡単な説明 - 作成者情報 - 作成日 - ライセンス情報 ### 例```javascript /** * 割引を適用した後の商品の合計価格を計算します。 * * @param {Array<Object> } items - 価格プロパティを持つアイテムオブジェクトの配列 * @param {number} discountPercent - 割引率 (0-100) * @returns {number} 割引後の合計価格 * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculateTotalPrice(items, 10); // 27 を返します */ function calculateTotalPrice(items, discountPercent) { // 実装 } ``` ```python def calculate_total_price(items, discount_percent): &quot;&quot;&quot; 割引を適用した後の商品の合計価格を計算します。 引数: items: 価格プロパティを持つ辞書のリスト discount_percent: 割引率 (0-100) 戻り値: float: 割引後の合計価格 例: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculate_total_price(items, 10) # 27 を返します &quot;&quot;&quot; # 実装 ``` ## コード構造 ### ファイルの構成 - ファイルごとに 1 つの主要なクラス/コンポーネント - 関連する機能を同じディレクトリにグループ化 - 適切な場合は、実装からインターフェイスを分離 - ファイルのサイズを適切なサイズに保つ (ガイドラインとして 500 行未満) ### 関数とメソッドのサイズ - 関数とメソッドを小さくして焦点を絞る - 1 つの機能を適切に実行する関数を目指す - 関数の長さを制限する (ガイドラインとして 50 行未満) - 複雑なロジックをヘルパー関数に抽出します。 ### 依存関係の管理 - モジュール間の依存関係を最小限に抑えます。 - 依存性の注入を使用して結合を減らします。 - モジュールの依存関係を明確に文書化します。 - 循環依存関係を避けます。 ### エラー処理 - 適切なレベルでエラーを処理します。 - 例外的な状況には例外を使用します。 - わかりやすいエラー メッセージを提供します。 - 正当な理由がない限り、例外を鵜呑みにしません。 ## 言語固有のガイドライン ### JavaScript/TypeScript - Airbnb JavaScript スタイル ガイドに従います。 - 適切な場合は ES6+ 機能を使用します。 - 型の安全性のために TypeScript を使用します。 - 関数型プログラミング パターンを優先します。 ```javascript // 変数が再割り当てされない場合は、let よりも const を優先します。 const PI = 3.14159; // 文字列補間にはテンプレート リテラルを使用します。 const greeting = `Hello, ${name}!`; // 分割代入を使用します。 const { firstName, lastName } = user; // 短いコールバックには矢印関数を使用します。 const doubled = numbers.map(n =&gt; n * 2); ``` ### Python - PEP 8 スタイル ガイドに従います - 型ヒントを使用します (PEP 484) - 単純なケースではリスト/辞書の内包表記を優先します - リソース管理にはコンテキスト マネージャーを使用します ```python # 単純な変換にはリストの内包表記を使用します doubled = [n * 2 for n in numbers] # リソース管理にはコンテキスト マネージャーを使用します with open(&quot;file.txt&quot;, &quot;r&quot;) as f: content = f.read() # 型ヒントを使用します def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; ``` ### HTML/CSS - セマンティック HTML 要素を使用します - CSS クラスには BEM 方法論に従います - インライン スタイルを最小限に抑えます - テーマ設定には CSS 変数を使用します ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title">タイトル</h2></header><div class="card__content"><p>ここにコンテンツが入ります</p></div></article>``` ```css /* テーマ設定に CSS 変数を使用する */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* BEM 方法論に従う */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## バージョン管理 ### コミットメッセージ - 明確で説明的なコミットメッセージを書く - 命令形を使用する（「機能を追加する」ではなく「機能が追加されました」） - 該当する場合は、問題番号を参照する - 従来のコミット形式に従う ``` 機能：ユーザー認証システムを追加する - JWT ベースの認証を実装する - ログインおよび登録エンドポイントを追加する - 認証ミドルウェアを作成する Closes #123 ``` ### ブランチ戦略 - 新規開発には機能ブランチを使用する - main/master ブランチを安定させる - コードレビューにはプルリクエストを使用する - マージ後にブランチを削除する ### コードレビュー - マージ前にすべてのコードをレビューする - アーキテクチャ、セキュリティ、パフォーマンスに焦点を当てる - コメントは建設的で敬意を持って行う - 自動化ツールを使用してスタイルの問題を検出する ## 結論 このスタイルガイドは、WhytCard コードベース全体の一貫性と品質を確保するために設計されています。一般的な原則を扱っていますが、より詳細なルールについては、言語固有のガイドを参照してください。目標は、保守可能で読みやすく、堅牢なコードを作成することであることを忘れないでください。すべてのチームメンバーは、これらのガイドラインに従い、コードレビューとメンタリングを通じてガイドラインの実施に協力することが期待されています。 --- 最終更新日: 2025年1月15日 