# Загальний посібник зі стилю для WhytCard ## Вступ Цей документ визначає загальний стиль кодування та найкращі практики, яких слід дотримуватися для всіх мов та технологій, що використовуються в проєкті WhytCard. Ці стандарти забезпечують узгодженість, зручність підтримки та якість усієї кодової бази. ## Зміст 1. [Фундаментальні принципи](#fundamental-principles) 2. [Правила іменування](#naming-conventions) 3. [Форматування](#formatting) 4. [Документація](#documentation) 5. [Структура коду](#code-structure) 6. [Керівні принципи для конкретної мови](#language-specific-guidelines) 7. [Контроль версій](#version-control) ## Фундаментальні принципи ### Чіткість над розумністю Завжди надавайте пріоритет чіткості коду над розумними або складними рішеннями: - Пишіть код, який легко зрозуміти - Уникайте незрозумілих мовних функцій, якщо це не необхідно - Надавайте пріоритет читабельності та зручності обслуговування над стислостю ### Узгодженість Підтримуйте узгодженість у всій кодовій базі: - Дотримуйтесь усталених шаблонів у проекті - Не змішуйте різні стилі чи підходи - Під час зміни існуючого коду узгоджуйте його стиль ### DRY (Не повторюйте себе) Уникайте дублювання коду: - Видобудьте повторюваний код у функції або класи - Створюйте спільні утиліти для спільних операцій - Використовуйте успадкування або композицію для спільної поведінки ### KISS (Keep It Simple (Будь простим, дурним)) Надавайте перевагу простим рішенням над складними: - Почніть з найпростішого підходу, який працює - Додавайте складність лише за необхідності - Розбийте складні проблеми на простіші частини ### YAGNI (You Are Gonna Need It (Вам Це Не Знадобиться)) Не додавайте функціональність, доки це не стане необхідним: - Уникайте спекулятивних можливостей - Реалізуйте лише те, що потрібно зараз - Рефакторуйте, коли це потрібно, а не превентивно ## Правила іменування ### Загальні правила - Назви повинні бути описовими та передавати мету - Використовуйте повні слова, а не скорочення (за винятком поширених) - Бути узгодженими з існуючими шаблонами іменування ### Стилі регістру Використовуйте відповідний стиль регістру для кожної мови: - **camelCase**: Змінні та функції JavaScript/TypeScript - **PascalCase**: Класи в більшості мов, компоненти React - **snake_case**: Змінні та функції Python - **kebab-case**: Елементи HTML, класи CSS, імена файлів - **UPPER_SNAKE_CASE**: Константи в більшості мов ### Приклади іменування ```javascript // JavaScript const userProfile = { firstName: «Джон», прізвище: «Доу», EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculateTotalPrice(items) { // Реалізація } class UserManager { // Реалізація } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculate_total_price(items): # Реалізація пройшла class UserManager: # Реалізація пройшла ``` ## Форматування ### Відступи - Використовуйте послідовні відступи по всьому проєкту - Для JavaScript/TypeScript/HTML/CSS: 2 пробіли - Для Python: 4 пробіли (PEP 8) - Ніколи не змішуйте табуляцію та пробіли ### Довжина рядка - Обмежте рядки максимум 100 символами для більшості мов - Для Python дотримуйтесь PEP 8 (79 символів для коду, 72 для коментарів) - Розбивайте довгі рядки природним для мови способом ### Інтервали - Використовуйте пробіли навколо операторів - Використовуйте пробіли після ком та крапки з комою - Використовуйте послідовні інтервали у функції виклики та оголошення ### Дужки та блоки - Відкриваючі дужки в одному рядку для більшості мов (за винятком функцій та класів Python) - Послідовне використання дужок навіть для однорядкових блоків - Вирівнювання закриваючих дужок з початком початкового рядка ### Приклади ```javascript // JavaScript function calculateDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculate_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Item 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Item 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Item 3&quot;, &quot;price&quot;: 30}, ] ``` ## Документація ### Коментарі до коду - Використовуйте коментарі для пояснення &quot;чому&quot;, а не &quot;що&quot; - Коментуйте складні алгоритми або неочевидні рішення - Оновлюйте коментарі відповідно до змін коду - Уникайте надлишкових або очевидних коментарів ### Документація функцій та методів Документуйте всі функції та методи з: - Описом призначення - Параметрами та їх типами - Поверненим значенням та типом - Винятками, які можуть бути викликані - Прикладами використання для складних функцій ### Заголовки файлів Включіть на початку кожного файлу: - Короткий опис призначення файлу - Інформацію про автора(ів) - Дату створення - Інформацію про ліцензію ### Приклади ```javascript /** * Обчислює загальну вартість товарів після застосування знижок. * * @param {Array<Object> } items - Масив об&#39;єктів товарів з властивістю price * @param {number} discountPercent - Відсоток знижки (0-100) * @returns {number} Загальна ціна після знижки * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculateTotalPrice(items, 10); // Повертає 27 */ function calculateTotalPrice(items, discountPercent) { // Реалізація } ``` ```python def calculate_total_price(items, discount_percent): &quot;&quot;&quot; Обчислює загальну ціну товарів після застосування знижок. Аргументи: items: Список словників з властивістю ціни discount_percent: Відсоток знижки (0-100) Повертає: float: Загальна ціна після знижки Приклад: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculate_total_price(items, 10) # Повертає 27 &quot;&quot;&quot; # Реалізація ``` ## Структура коду ### Організація файлів - Один основний клас/компонент на файл - Групування пов&#39;язаних функцій в одному каталозі - Окремий інтерфейс від реалізації, коли це доречно - Зберігайте файли розумного розміру (&lt; 500 рядків як рекомендація) ### Розмір функцій та методів - Зберігайте функції та методи невеликими та сфокусованими - Прагніть до функцій, які добре виконують одну річ - Обмежуйте довжину функції (&lt; 50 рядків як рекомендація) - Виділяйте складну логіку в допоміжний модуль функції ### Керування залежностями - Мінімізація залежностей між модулями - Використовування впровадження залежностей для зменшення зв&#39;язків - Чітко документування залежностей модулів - Уникнення циклічних залежностей ### Обробка помилок - Обробка помилок на відповідному рівні - Використовування винятків для виняткових умов - Надання змістовних повідомлень про помилки - Не ігнорування винятків без вагомої причини ## Рекомендації щодо мови програмування ### JavaScript/TypeScript - Дотримуйтесь посібника зі стилю Airbnb JavaScript - Використовування функцій ES6+, коли це доречно - Використовування TypeScript для безпеки типів - Віддавання переваги шаблонам функціонального програмування ```javascript // Віддавайте перевагу const над let, коли змінна не буде перепризначена const PI = 3.14159; // Використовування літералів шаблонів для інтерполяції рядків const greeting = `Hello, ${name}!`; // Використовування деструктуризації присвоєння const { firstName, lastName } = user; // Використовування стрілкових функцій для коротких зворотних викликів const doubled = numbers.map(n =&gt; n * 2); ``` ### Python - Дотримуйтесь посібника зі стилю PEP 8 - Використовуйте підказки типів (PEP 484) - Надавайте перевагу списковим/словниковим формулям для простих випадків - Використовуйте менеджери контексту для керування ресурсами ```python # Використовуйте спискові формули для простих перетворень doubled = [n * 2 for n in numbers] # Використовуйте менеджери контексту для керування ресурсами with open(&quot;file.txt&quot;, &quot;r&quot;) as f: content = f.read() # Використовуйте підказки типів def greet(name: str) -&gt; str: return f&quot;Привіт, {name}!&quot; ``` ### HTML/CSS - Використовуйте семантичні елементи HTML - Дотримуйтесь методології BEM для класів CSS - Мінімізуйте вбудовані стилі - Використовуйте змінні CSS для тематизації ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title"> Назва</h2></header><div class="card__content"><p> Контент розміщується тут</p></div></article> ``` ```css /* Використання змінних CSS для створення тем */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* Дотримуйтесь методології BEM */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## Контроль версій ### Повідомлення комітів - Пишіть чіткі, описові повідомлення комітів - Використовуйте наказовий спосіб (&quot;Додати функцію&quot;, а не &quot;Додана функція&quot;) - Посилайтеся на номери проблем, коли це можливо - Дотримуйтесь звичайного формату комітів ``` feat: додати систему автентифікації користувачів - Реалізуйте автентифікацію на основі JWT - Додайте кінцеві точки входу та реєстрації - Створіть проміжне програмне забезпечення автентифікації Закриває #123 ``` ### Стратегія розгалуження - Використовуйте гілки функцій для нової розробки - Зберігайте стабільність основної/головної гілки - Використовуйте запити на зняття для перевірки коду - Видаляйте гілки після злиття ### Перевірки коду - Переглядайте весь код перед злиттям - Зосередьтеся на архітектурі, безпеці та продуктивності - Будьте конструктивними та шанобливими в коментарях - Використовуйте автоматизовані інструменти для виявлення проблем стилю ## Висновок Цей посібник зі стилю розроблений для забезпечення узгодженості та якості в кодовій базі WhytCard. Хоча він охоплює загальні принципи, зверніться до посібників з конкретних мов для отримання детальніших правил. Пам&#39;ятайте, що метою є створення зручного для підтримки, читабельного та надійного коду. Очікується, що всі члени команди дотримуватимуться цих рекомендацій та допомагатимуть їх впроваджувати через перевірки коду та наставництво. --- Останнє оновлення: 2025-01-15 