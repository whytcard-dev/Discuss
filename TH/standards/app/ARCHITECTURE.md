# สถาปัตยกรรมระดับโลกของ WhytCard 

## บทนำ 

เอกสารนี้แสดงสถาปัตยกรรมระดับโลกของโครงการ WhytCard ซึ่งเป็นแพลตฟอร์มการฝึกอบรม AI และการสแกนเว็บแบบโอเพ่นซอร์ส สถาปัตยกรรมนี้ได้รับการออกแบบให้เป็นแบบโมดูลาร์ ปรับขนาดได้ และบำรุงรักษาได้ ช่วยให้เพิ่มฟีเจอร์ใหม่ได้ง่ายในขณะที่ยังรักษาเสถียรภาพของระบบได้ 

## ภาพรวม 

WhytCard จัดระเบียบตามสถาปัตยกรรมไคลเอนต์-เซิร์ฟเวอร์โดยมีการแยกส่วนฟรอนต์เอนด์และแบ็กเอนด์อย่างชัดเจน การแยกส่วนนี้ช่วยให้สามารถพัฒนาส่วนประกอบทั้งสองได้อย่างอิสระและอำนวยความสะดวกในการทำงานเป็นทีม 

``` 
┌──────────────────┐ ┌──────────────────┐ 
│ │ │ │ │ 
│ ส่วนหน้า │◄────►│ ส่วนหลัง │ 
│ (Vue.js) │ │ (FastAPI) │ 
│ │ │ │ 
└─────────────────────┘ └─────────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ 
│ │ 
│ การสแกนและ │ 
│ ไพพ์ไลน์ข้อมูล │ 
│ │ 
└───────────────────┘ 
▲ 
│ 
▼ 
┌─────────────────┐ 
│ │ 
│ การจัดเก็บ │ 
│ │ 
└─────────────────────┘ 
``` 

## หลัก ส่วนประกอบ 

### 1. Frontend (Vue.js) 

Frontend ได้รับการพัฒนาด้วย Vue.js และใช้ Tailwind CSS สำหรับการออกแบบ โดยมีหน้าที่รับผิดชอบอินเทอร์เฟซผู้ใช้และประสบการณ์ผู้ใช้ 
#### คุณสมบัติหลัก 

- **Framework**: Vue.js 3 พร้อม Composition API 
- **Styling**: Tailwind CSS 
- **Animations**: Framer Motion 
- **Internationalization**: i18next พร้อมการตรวจจับภาษาเบราว์เซอร์อัตโนมัติ 
- **Routing**: Vue Router 
- **State Management**: Pinia 

#### Structure 

``` 
src/ 
├── components/ # ส่วนประกอบที่นำกลับมาใช้ใหม่ได้ 
├── config/ # การกำหนดค่าส่วนหน้า 
├── i18n/ # ไฟล์การแปล 
├── router/ # การกำหนดค่าเส้นทาง 
├── views/ # หน้าหลัก 
└── main.js # จุดเข้า 
``` 

### 2. แบ็กเอนด์ (FastAPI) 

แบ็กเอนด์ได้รับการพัฒนาด้วย FastAPI กรอบงาน Python ที่ทันสมัยและประสิทธิภาพสูงสำหรับการสร้าง API จัดการการทำงานของเซิร์ฟเวอร์ การเข้าถึงข้อมูล และตรรกะทางธุรกิจทั้งหมด

#### คุณสมบัติหลัก 

- **กรอบงาน**: FastAPI 
- **การรับรองความถูกต้อง**: JWT 
- **การตรวจสอบความถูกต้อง**: Pydantic 
- **เอกสาร API**: Swagger UI แบบบูรณาการ 

#### โครงสร้าง 

``` 

backend/ 
├── config/ # การกำหนดค่าแบ็กเอนด์ 
├── core/ # ตรรกะทางธุรกิจหลัก 
│ ├── api/ # จุดสิ้นสุดของ API 
│ └── schemas/ # schemas Pydantic 
├── models/ # data models 
├── utils/ # ยูทิลิตี้ 
└── main.py # จุดเข้า 
``` 

### 3. การสแกนและไปป์ไลน์ข้อมูล 

โมดูลนี้ มีหน้าที่รับผิดชอบในการรวบรวมข้อมูลจากแหล่งบนเว็บและแปลงข้อมูลดังกล่าวเพื่อใช้ในการฝึกอบรมโมเดล AI
#### คุณสมบัติหลัก 

- **การขูดข้อมูล**: ระบบอะซิงโครนัสที่มี aiohttp และ BeautifulSoup 
- **การประสานการทำงาน**: การจัดการงานและลำดับความสำคัญ 
- **การแปลงข้อมูล**: การทำความสะอาดและการทำให้ข้อมูลเป็นมาตรฐาน 
- **แคช**: ระบบการแคชเพื่อหลีกเลี่ยงคำขอซ้ำซ้อน 

#### โครงสร้าง 

``` 
backend/ 
├── การขูดข้อมูล/ 
│ ├── เครื่องขูดข้อมูล/ # การใช้งานเฉพาะสำหรับแหล่งต่างๆ 
│ ├── utils/ # ยูทิลิตี้การขูดข้อมูล 
│ ├── orchestrator.py # เครื่องประสานการทำงาน 
│ └── cache.py # ระบบการแคช 
└── datasets/ # ข้อมูลที่รวบรวมและแปลงแล้ว 
``` 

### 4. ระบบจัดเก็บข้อมูล 

ระบบจัดเก็บข้อมูลช่วยจัดการความคงอยู่และการเข้าถึงข้อมูล 

#### ตัวเลือกการจัดเก็บ 

- **ฐานข้อมูล**: PostgreSQL สำหรับข้อมูลที่มีโครงสร้าง 
- **การจัดเก็บไฟล์**: ระบบไฟล์ภายในหรือเข้ากันได้กับ S3 สำหรับข้อมูลขนาดใหญ่ 
- **แคช**: Redis สำหรับแคชแบบกระจาย 

## การไหลของข้อมูล 

### 1. การรวบรวมข้อมูล 

`` 
┌──────────────┐ ┌────────────────┐ ┌───────────────┐ 
│ │ │ │ │ │ │ │ 
│ เว็บ │────►│ เครื่องมือสแกนข้อมูล │────►│ แคช │ 
│ แหล่งที่มา │ │ │ │ │ │ 
└───────────────┘ └──────────────── 
│ 
▼ 
┌──────────────┐ ┌─────────────┐ 
│ │ │ │ │ 
│ โปรเซสเซอร์ │────►│ ที่เก็บข้อมูล │ 
│ │ │ │ 
└──────────────┘ └─────────────┘ 
``` 

1. โปรแกรมรวบรวมข้อมูลรวบรวมข้อมูลจากแหล่งข้อมูลบนเว็บ 
2. ข้อมูลจะถูกแคชเพื่อหลีกเลี่ยงคำขอซ้ำซ้อน 
3. โปรเซสเซอร์จะทำความสะอาดและแปลงข้อมูล 
4. ข้อมูลที่แปลงแล้วจะถูกเก็บไว้เพื่อใช้ในภายหลัง 

### 2. การฝึกอบรมโมเดล 

``` 
┌──────────────┐ ┌──────────────┐ ┌─────────────┐ 
│ │ │ │ │ │ │ │ 
│ ชุดข้อมูล │────►│ พรีโปรเซสเซอร์│────►│ การฝึกอบรม │ 
│ │ │ │ │ │ 
└──────────────┘ └──────────────┘ └──────────────┘ 
│ 
▼ 
┌──────────────┐ 
│ │ 
│ โมเดล │ 
│ │ 
└─────────────┘ 
``` 

1. ชุดข้อมูลจะถูกแยกออกมาจากที่จัดเก็บ 
2. ข้อมูลจะถูกประมวลผลล่วงหน้าเพื่อการฝึก 
3. โมเดลจะถูกฝึกบนข้อมูลที่ประมวลผลล่วงหน้า 
4. โมเดลที่ฝึกแล้วจะถูกบันทึก 

### 3. การใช้งานโมเดล 

``` 
┌─────────────┐ ┌──────────────┐ ┌─────────────┐ 
│ │ │ │ │ │ │ │ 
│ API │────►│ โมเดล │────►│ การตอบสนอง │ 
│ คำขอ │ │ │ │ │ │ 
└─────────────┘ └───────────────┘ └──────────────┘ 
``` 

1. ได้รับคำขอ API 

2. ใช้โมเดลที่เหมาะสมในการประมวลผลคำขอ 

3. สร้างและส่งคืนการตอบกลับ 

## การสื่อสารระหว่างคอมโพเนนต์ 

### REST API 

การสื่อสารระหว่างส่วนหน้าและส่วนหลังนั้นส่วนใหญ่จะใช้ผ่าน REST API จุดสิ้นสุดได้รับการจัดระเบียบและบันทึกอย่างมีตรรกะโดยใช้ Swagger UI 

### WebSockets 

สำหรับคุณลักษณะที่ต้องการการอัปเดตแบบเรียลไทม์ (เช่น การติดตามงานการขูดข้อมูล) WebSockets จะถูกใช้เพื่อเปิดใช้งานการสื่อสารแบบสองทิศทาง 

### คิวข้อความ 

สำหรับงานที่ไม่ซิงโครไนซ์และทำงานเป็นเวลานาน คิวข้อความ (เช่น RabbitMQ หรือ Redis Pub/Sub) จะถูกใช้เพื่อแยกส่วนประกอบและรับรองความน่าเชื่อถือ 

## การปรับใช้ 

### ตัวเลือกการปรับใช้ 

WhytCard สามารถใช้งานได้หลายวิธี: 

1. **แอปพลิเคชันเดสก์ท็อป**: ใช้ Tauri เพื่อสร้างแอปพลิเคชันเดสก์ท็อปข้ามแพลตฟอร์ม 
2. **การปรับใช้บนคลาวด์**: การปรับใช้บนบริการคลาวด์ เช่น AWS, GCP หรือ Azure 
3. **การโฮสต์ด้วยตนเอง**: การติดตั้งบนเซิร์ฟเวอร์ส่วนตัวหรือของบริษัท 

### สถาปัตยกรรมการปรับใช้ 

``` 
┌────────────────────┐ ┌───────────────────┐ 
│ │ │ │ 
│ ส่วนหน้า │◄─────►│ API Gateway │ 
│ (แบบคงที่) │ │ │ 
└──────────────────────┘ └─────────────────── 
▲ 
│ 
▼ 
┌──────────────────┐ 
│ │ 
│ API แบ็กเอนด์ │ 
│ │ 
└───────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ ┌──────────────────┐ 
│ │ │ │ │ 
│ ฐานข้อมูล │ │ ที่เก็บไฟล์ │ 
│ │ │ │ 
└────────────────────────┘ └───────────────────── 
``` 

## ความปลอดภัย 

### หลักการรักษาความปลอดภัย 

1. **การป้องกันเชิงลึก**: ความปลอดภัยหลายชั้น 
2. **หลักการของสิทธิ์ขั้นต่ำ**: การเข้าถึงที่จำเป็นน้อยที่สุด 
3. **การตรวจสอบอินพุต**: ตรวจสอบอินพุตของผู้ใช้ทั้งหมด 
4. **การป้องกันข้อมูล**: การเข้ารหัสข้อมูลที่ละเอียดอ่อน 

### มาตรการรักษาความปลอดภัย 

- **การรับรองความถูกต้อง**: JWT พร้อมการหมุนเวียนโทเค็น 
- **การอนุญาต**: การควบคุมการเข้าถึงตามบทบาท 
- **การป้องกันการโจมตีทั่วไป**: XSS, CSRF, การแทรก SQL 
- **การตรวจสอบ**: การบันทึกการดำเนินการที่สำคัญ 

## ความสามารถในการปรับขนาด 

สถาปัตยกรรมได้รับการออกแบบให้ปรับขนาดได้ทั้งในแนวนอนและแนวตั้ง: 

- **ไมโครเซอร์วิส**: สามารถปรับใช้ส่วนประกอบต่างๆ ได้อย่างอิสระ 
- **การแคช**: การใช้แคชหลายระดับ 
- **การปรับสมดุลโหลด**: การกระจายปริมาณการรับส่งข้อมูลระหว่างอินสแตนซ์หลายอินสแตนซ์ 
- **การแบ่งพาร์ติชัน**: การแยกข้อมูลเพื่อปรับปรุงประสิทธิภาพ 

## การตรวจสอบและ การสังเกต 

- **การบันทึกข้อมูล**: การบันทึกข้อมูลแบบรวมศูนย์ด้วย ELK Stack หรือเทียบเท่า 
- **ตัวชี้วัด**: การรวบรวมตัวชี้วัดด้วย Prometheus 
- **การติดตาม**: การติดตามคำขอด้วย OpenTelemetry 
- **การแจ้งเตือน**: การแจ้งเตือนตามเกณฑ์ที่กำหนดไว้ล่วงหน้า 

## ข้อสรุป 

สถาปัตยกรรมของ WhytCard ได้รับการออกแบบมาให้แข็งแกร่ง ปรับขนาดได้ และบำรุงรักษาได้ การแบ่งความรับผิดชอบอย่างชัดเจนระหว่างส่วนประกอบต่างๆ ช่วยให้พัฒนาได้อย่างอิสระและอำนวยความสะดวกในการทำงานเป็นทีม การเลือกเทคโนโลยีนั้นพิจารณาจากความต้องการของโครงการในปัจจุบันและอนาคต รวมถึงแนวทางปฏิบัติที่ดีที่สุดในอุตสาหกรรม 

สถาปัตยกรรมนี้จะได้รับการตรวจสอบและอัปเดตเป็นประจำเพื่อให้ปรับให้เข้ากับความต้องการใหม่ๆ และการพัฒนาด้านเทคโนโลยี 

--- 

อัปเดตล่าสุด: 2025-01-15