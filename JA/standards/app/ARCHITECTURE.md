# WhytCard のグローバルアーキテクチャ

## はじめに

このドキュメントでは、オープンソースの Web スクレイピングおよび AI トレーニング プラットフォームである WhytCard プロジェクトのグローバルアーキテクチャについて説明します。このアーキテクチャはモジュール化され、スケーラブルで保守性に優れているため、システムの安定性を確保しながら、新機能を簡単に追加できます。

## 概要

WhytCard は、フロントエンドとバックエンドを明確に分離したクライアントサーバーアーキテクチャに基づいています。この分離により、両方のコンポーネントを独立して進化させることができ、チームワークを促進します。

``` 
┌─────────────────┐ ┌────────────────┐ 
│ │ │ │ 
│ フロントエンド │◄────►│ バックエンド │ 
│ (Vue.js) │ │ (FastAPI) │ 
│ │ │ │ 
└──────────────────┘ └──────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ 
│ │ 
│ スクレイピング & │ 
│ データパイプライン │ 
│ │ 
└──────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ 
│ │ 
│ ストレージ│ 
│ │ 
└──────────────────┘ 
``` 

## 主要コンポーネント

### 1. フロントエンド (Vue.js)

フロントエンドはVue.jsで開発され、スタイル設定にはTailwind CSSを使用しています。ユーザーインターフェースとユーザーエクスペリエンスを担います。

#### 主な機能

- **フレームワーク**: Vue.js 3（Composition API 付き）
- **スタイル**: Tailwind CSS
- **アニメーション**: Framer Motion
- **国際化**: i18next（ブラウザ言語自動検出機能付き）
- **ルーティング**: Vue Router
- **状態管理**: Pinia

#### 構造

``` 
src/ 
├── components/ # 再利用可能なコンポーネント
├── config/ # フロントエンド設定
├── i18n/ # 翻訳ファイル
├── router/ # ルート設定
├── views/ # メインページ
└── main.js # エントリポイント
```

### 2. バックエンド（FastAPI）

バックエンドは、API 作成用の最新かつ高性能な Python フレームワークである FastAPI を使用して開発されています。すべてのサーバー操作、データアクセス、ビジネスロジックを処理します。

#### 主な機能

- **フレームワーク**: FastAPI
- **認証**: JWT
- **検証**: Pydantic
- **APIドキュメント**: 統合されたSwagger UI

#### 構造

``` 
backend/
├── config/ # バックエンド設定
├── core/ # メインビジネスロジック
│ ├── api/ # APIエンドポイント
│ └── schemas/ # Pydanticスキーマ
├── models/ # データモデル
├── utils/ # ユーティリティ
└── main.py # エントリポイント
```

### 3. スクレイピングとデータパイプライン

このモジュールは、Webソースからデータを収集し、AIモデルのトレーニング用に変換する役割を担います。

#### 主な機能

- **スクレイピング**: aiohttp と BeautifulSoup を使用した非同期システム
- **オーケストレーション**: タスクと優先度の管理
- **変換**: データのクリーニングと正規化
- **キャッシュ**: 冗長なリクエストを回避するためのキャッシュシステム

#### 構造

``` 
backend/ 
├── scraping/ 
│ ├── scrapers/ # 異なるソース向けの実装
│ ├── utils/ # スクレイピングユーティリティ
│ ├── Orchestrator.py # タスクオーケストレーター
│ └── cache.py # キャッシュシステム
└── datasets/ # 収集および変換されたデータ
```

### 4. ストレージ

ストレージシステムは、データの永続性とアクセスを管理します。

#### ストレージオプション

- **データベース**: 構造化データ用 PostgreSQL
- **ファイルストレージ**: 大規模データ用 ローカルファイルシステムまたは S3 互換
- **キャッシュ**: 分散キャッシュ用 Redis

## データフロー

### 1. データ収集

```
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ 
│ │ │ │ │ │ 
│ Web │────►│ スクレーパー │────►│ キャッシュ │ 
│ ソース │ │ │ │ └───────────┘ └──────────────┘ └──────────────┘ 
│ 
▼
┌──────────────┐ ┌─────────────┐ 
│ │ │ │ 
│ プロセッサ │────►│ ストレージ │ 
│ │ │ │ 
└─────────────┘ └─────────────┘ 
``` 

1. スクレーパーがWebソースからデータを収集します。
2. データは冗長なリクエストを避けるためにキャッシュされます。
3. プロセッサがデータをクリーンアップして変換します。
4. 変換されたデータは後で使用するために保存されます。

### 2. モデルのトレーニング

``` 
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ 
│ │ │ │ │ │ 
│ データセット │────►│ プリプロセッサ │────►│ トレーニング │ 
│ │ │ │ │ │ 
└──────────────┘ └──────────────┘ └──────────────┘ 
│ 
▼ 
┌──────────────┐ 
│ │ 
│ モデル │ 
│ │ 
└──────────────┘ 
``` 

1. データセットがストレージから抽出されます。
2. データがトレーニング用に前処理されます。
3. 前処理されたデータでモデルがトレーニングされます。
4. トレーニング済みのモデルが保存されます。

### 3. モデルの使用

``` 
┌──────────────┐ ┌──────────────┐ ┌──────────────┐ 
│ │ │ │ │ │ 
│ API │────►│ モデル │────►│レスポンス │ 
│ リクエスト │ │ │ │ 
└──────────────┘ └──────────────┘ └──────────────┘ 
``` 

1. API リクエストを受信します。
2. 適切なモデルを使用してリクエストを処理します。
3. レスポンスが生成され、返されます。

## コンポーネント間の通信

### REST API

フロントエンドとバックエンド間の通信は、主に REST API を介して行われます。エンドポイントは Swagger UI を使用して論理的に整理され、ドキュメント化されます。

### WebSocket

リアルタイム更新を必要とする機能（スクレイピングタスクの追跡など）では、双方向通信を可能にするために WebSocket が使用されます。

### メッセージキュー

非同期および長時間実行タスクでは、コンポーネントを分離し、信頼性を確保するためにメッセージキュー（RabbitMQ や Redis Pub/Sub など）が使用されます。

## デプロイメント

### デプロイメントオプション

WhytCard は複数の方法でデプロイできます。

1. **デスクトップアプリケーション**: Tauri を使用してクロスプラットフォームのデスクトップアプリケーションを作成する
2. **クラウドデプロイメント**: AWS、GCP、Azure などのクラウドサービスにデプロイする
3. **セルフホスティング**: 個人または会社のサーバーにインストールする

### デプロイメントアーキテクチャ

```
┌─────────────────┐ ┌─────────────────┐
│ │ │ │
│ フロントエンド │◄────►│ API ゲートウェイ │
│ (静的) │ │ │
└────────────────┘ └──────────────────┘
▲ 
│ 
▼ 
┌──────────────────┐
│ │ 
│ バックエンド API │ 
│ │ 
└──────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ ┌──────────────────┐ 
│ │ │ │ 
│ データベース │ │ ファイルストレージ │ 
│ │ │ │ 
└──────────────────┘ └──────────────────┘ 
``` 

## セキュリティ

### セキュリティ原則

1. **多層防御**: 複数のセキュリティレイヤー
2. **最小権限の原則**: 必要最小限のアクセス
3. **入力検証**: すべてのユーザー入力が検証されます
4. **データ保護**: 機密データの暗号化

### セキュリティ対策

- **認証**: トークンローテーションを備えたJWT
- **認可**: ロールベースアクセス制御
- **一般的な攻撃からの保護**: XSS、CSRF、SQLインジェクション
- **監査**: 重要なアクションのログ記録

## スケーラビリティ

アーキテクチャは、水平方向と垂直方向のスケーラビリティを実現するように設計されています。

- **マイクロサービス**: コンポーネントを個別にデプロイ可能
- **キャッシュ**: マルチレベルキャッシュの使用
- **負荷分散**: 複数のインスタンス間でのトラフィック分散
- **パーティショニング**: パフォーマンス向上のためのデータ分離

## モニタリングと可観測性

- **ロギング**: ELK Stackまたは同等のツールによる集中ロギング
- **メトリクス**: Prometheusによるメトリクス収集
- **トレース**: OpenTelemetryによるリクエスト追跡
- **アラート**: 事前定義されたしきい値に基づくアラート

##結論

WhytCardのアーキテクチャは、堅牢性、拡張性、保守性を考慮して設計されています。各コンポーネント間の責任の明確な分離により、独立した進化が可能になり、チームワークが促進されます。テクノロジーの選択は、現在および将来のプロジェクトニーズ、そして業界のベストプラクティスを考慮して行われました。

このアーキテクチャは、新たなニーズや技術開発に対応するため、定期的にレビューと更新が行われます。

---

最終更新日：2025年1月15日