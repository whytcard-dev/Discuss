# 代码质量标准

## 核心原则

- 编写简洁、可维护且自文档化的代码
- 遵循 SOLID 和 DRY 原则
- 保持函数简洁且专注（单一职责）
- 对变量、函数和类使用描述性命名
- 在整个项目中保持一致的代码风格
- 记录复杂的逻辑和公共 API
- 为人类编写代码，而不仅仅是机器

## JavaScript/TypeScript 标准

### TypeScript 配置

- 使用严格模式（“strict”: true）
- 启用所有推荐的类型检查选项
- 配置正确的模块解析
- 设置合适的目标 ECMAScript 版本
- 指定包含/排除模式
- 使用路径别名进行更简洁的导入

### 命名约定

- **变量/函数**：驼峰命名法（`getUserData`、`calculateTotal`）
- **类/接口/类型**：帕斯卡命名法(`UserProfile`, `ApiResponse`)
- **常量**: 大写蛇形命名法 (`MAX_RETRY_COUNT`, `API_URL`)
- **私有属性**: 使用 `#` 前缀或 `_` 约定 (`#privateField`, `_privateMethod`)
- **布尔变量**: 使用 "is", "has", "can" 前缀 (`isActive`, `hasPermission`)
- **组件文件**: 使用 PascalCase 命名法，并附带扩展名 (`UserCard.tsx`)
- **实用程序文件**: 使用 camelCase 命名法，并附带扩展名 (`formatDate.ts`)

### 代码组织

- 每个文件一个类/组件
- 按外部/内部分组导入
- 按字母顺序排列导入
- 使用桶式导出 (`index.ts`) 来存放相关功能
- 按功能/模块组织代码
- 将文件放在400 行（如果超过则拆分）
- 函数代码量控制在 50 行以内
- 最大嵌套层数：3-4 层

### 最佳实践

- 优先使用不可变性（const、readonly、Object.freeze）
- 使用可选链和空值合并
- 实现适当的错误处理
- 除非必要，否则避免使用任何类型
- 使用类型保护进行运行时类型检查
- 优先使用 async/await 而不是原始 Promise
- 避免使用魔法数字和字符串（使用常量）
- 实现适当的 null/undefined 检查
- 使用提前返回以减少嵌套

## React 标准

### 组件结构

- 优先使用带有 hooks 的函数式组件
- 对组件使用命名导出
- 使用 TypeScript 实现 prop 验证
- 将复杂逻辑提取到自定义 hooks
- 使组件专注于 UI 关注点
- 实现适当的错误边界
- 使用 React.memo 进行性能优化
- 提取可复用组件

### 状态管理

- 使用本地状态来管理组件特定数据
- 使用 context 来管理跨组件共享状态
- 对于复杂的应用，考虑使用外部状态管理
- 保持状态规范化和最小化
- 实现合理的状态初始化
- 使用 Reducer 来处理复杂的状态逻辑
- 避免 prop 钻取（使用组合或 context）

### 性能优化

- 使用 React.memo 来处理纯组件
- 实现 useMemo 来处理开销较大的计算
- 使用 useCallback 来处理函数记忆化
- 虚拟化长列表（react-window、react-virtualized）
- 在 hooks 中实现合理的依赖数组
- 避免不必要的重新渲染
- 使用 React Profiler 来识别瓶颈

## 测试标准

### 单元测试

- 测试所有业务逻辑和工具
- 使用 Jest 或 Vitest 作为测试运行器
- 实现合理的依赖模拟
- 使用测试库进行组件测试
- 遵循 AAA 模式（Arrange、Act、Assert）
- 编写描述性测试名称
- 目标代码覆盖率 > 80%
- 测试边缘情况和错误场景

### 集成测试

- 测试组件交互
- 测试表单提交和用户流程
- 使用 MSW 进行 API 模拟
- 测试路由和导航
- 验证状态变化
- 使用真实数据进行测试

### 端到端测试

- 使用 Cypress 或 Playwright
- 测试关键用户旅程
- 在多个浏览器上进行测试
- 实施适当的测试隔离
- 使用数据属性作为测试选择器
- 为不稳定测试实施重试逻辑
- 测试可访问性

## 代码审查标准

### 流程

- 所有代码在合并前必须经过审查
- 审查前必须通过自动化检查
- 使用拉取请求模板
- 保持 PR 简短且重点突出
- 及时回复审查意见
- 合并前解决所有意见
- 合并前压缩提交

### 审查检查清单

- 代码符合项目标准
- 包含并通过测试
- 文档已更新
- 无安全漏洞
- 考虑性能影响
- 满足可访问性要求
- 处理边缘情况
- 无不必要的代码或依赖项

## 工具

### 代码检查和格式化

- 使用 ESLint 并设置适当的规则
- 使用 Prettier 进行格式一致性检查
- 使用 Husky 进行预提交钩子
- 使用 lint-staged 进行增量代码检查
- 使用 TypeScript 编译器进行类型检查
- 使用 Stylelint 进行 CSS/SCSS 代码检查

### 静态分析

- SonarQube 或 CodeClimate
- 复杂度指标监控
- 重复代码检测
- 安全漏洞扫描
- 包大小分析
- 未使用代码检测

### CI/CD 集成

- 对每个 PR 运行所有检查
- 如果检查失败，则阻止合并
- 生成并发布测试覆盖率报告
- 实施性能回归测试
- 自动化依赖项更新
- 部署预览环境