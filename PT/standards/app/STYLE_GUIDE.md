# Guia de Estilo Geral para WhytCard ## Introdução Este documento define o estilo geral de codificação e as melhores práticas a serem seguidas em todas as linguagens e tecnologias utilizadas no projeto WhytCard. Esses padrões garantem consistência, manutenibilidade e qualidade em toda a base de código. ## Índice 1. [Princípios Fundamentais](#princípios-fundamentais) 2. [Convenções de Nomenclatura](#convenções-de-nomeação) 3. [Formatação](#formatação) 4. [Documentação](#documentação) 5. [Estrutura do Código](#estrutura-do-código) 6. [Diretrizes Específicas da Linguagem](#diretrizes-específicas-da-linguagem) 7. [Controle de Versão](#controle-de-versão) ## Princípios Fundamentais ### Clareza em Vez de Inteligência Priorize sempre a clareza do código em vez de soluções inteligentes ou complexas: - Escreva código que seja fácil de entender - Evite recursos obscuros da linguagem, a menos que seja necessário - Priorize a legibilidade e a manutenibilidade em vez da brevidade ### Consistência Mantenha a consistência em toda a base de código: - Siga os padrões estabelecidos no projeto - Não misture estilos ou abordagens diferentes - Ao modificar o código existente, combine seu estilo ### DRY (Não se repita) Evite duplicação de código: - Extraia código repetido em funções ou classes - Crie utilitários para operações comuns - Use herança ou composição para compartilhar comportamento ### KISS (Keep It Simple, Stupid) Prefira soluções simples às complexas: - Comece com a abordagem mais simples que funciona - Adicione complexidade somente quando necessário - Divida problemas complexos em partes mais simples ### YAGNI (You Aren&#39;t Gonna Need It) Não adicione funcionalidade até que seja necessário: - Evite recursos especulativos - Implemente somente o que é necessário agora - Refatore quando necessário, não preventivamente ## Convenções de Nomenclatura ### Regras Gerais - Os nomes devem ser descritivos e transmitir propósito - Use palavras completas em vez de abreviações (exceto as comuns) - Seja consistente com os padrões de nomenclatura existentes ### Estilos de Caixa Use o estilo de caixa apropriado para cada linguagem: - **camelCase**: variáveis e funções JavaScript/TypeScript - **PascalCase**: classes na maioria das linguagens, componentes React - **snake_case**: variáveis e funções Python - **kebab-case**: elementos HTML, classes CSS, nomes de arquivo - **UPPER_SNAKE_CASE**: constantes em a maioria dos idiomas ### Exemplos de nomenclatura ```javascript // JavaScript const userProfile = { firstName: &#39;John&#39;, lastName: &#39;Doe&#39;, EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculateTotalPrice(items) { // Implementação } class UserManager { // Implementação } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculate_total_price(items): # Implementação pass class UserManager: # Implementação pass ``` ## Formatação ### Recuo - Use recuo consistente em todo o projeto - Para JavaScript/TypeScript/HTML/CSS: 2 espaços - Para Python: 4 espaços (PEP 8) - Nunca misture tabulações e espaços ### Comprimento da linha - Limite as linhas a um máximo de 100 caracteres para a maioria das linguagens - Para Python, siga o PEP 8 (79 caracteres para código, 72 para comentários) - Quebre linhas longas de uma forma natural para a linguagem ### Espaçamento - Use espaços em torno de operadores - Use espaços após vírgulas e ponto e vírgula - Use espaçamento consistente em chamadas de função e declarações ### Colchetes e blocos - Abrindo colchetes na mesma linha para a maioria das linguagens (exceto para funções e classes Python) - Uso consistente de colchetes mesmo para blocos de linha única - Alinhe os colchetes de fechamento com o início da linha de abertura ### Exemplos ```javascript // Função JavaScript calculateDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculate_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Item 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Item 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Item 3&quot;, &quot;price&quot;: 30}, ] ``` ## Documentação ### Comentários de código - Use comentários para explicar &quot;por que&quot;, não &quot;o quê&quot; - Comente algoritmos complexos ou soluções não óbvias - Mantenha os comentários atualizados com as alterações do código - Evite comentários redundantes ou óbvios ### Documentação de funções e métodos Documente todas as funções e métodos com: - Descrição da finalidade - Parâmetros e seus tipos - Valor e tipo de retorno - Exceções que podem ser geradas - Exemplos de uso para funções complexas ### Cabeçalhos de arquivo Inclua no início de cada arquivo: - Breve descrição da finalidade do arquivo - Informações do(s) autor(es) - Data de criação - Informações da licença ### Exemplos ```javascript /** * Calcula o preço total dos itens após aplicar descontos. * * @param {Array<Object> } items - Matriz de objetos de item com propriedade de preço * @param {number} discountPercent - Porcentagem de desconto (0-100) * @returns {number} Preço total após o desconto * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculateTotalPrice(items, 10); // Retorna 27 */ function calculateTotalPrice(items, discountPercent) { // Implementação } ``` ```python def calculate_total_price(items, discount_percent): &quot;&quot;&quot; Calcula o preço total dos itens após aplicar os descontos. Args: items: Lista de dicionários com a propriedade price discount_percent: Porcentagem de desconto (0-100) Retorna: float: Preço total após o desconto Exemplo: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculate_total_price(items, 10) # Retorna 27 &quot;&quot;&quot; # Implementação ``` ## Estrutura do código ### Organização de arquivos - Uma classe/componente primário por arquivo - Agrupe funcionalidades relacionadas no mesmo diretório - Separe a interface da implementação quando apropriado - Mantenha os arquivos com tamanho razoável (&lt; 500 linhas como orientação) ### Tamanho da função e do método - Mantenha as funções e os métodos pequenos e focados - Busque funções que façam uma coisa bem - Limite o tamanho da função (&lt; 50 linhas como diretriz) - Extraia lógica complexa em funções auxiliares ### Gerenciamento de dependências - Minimize dependências entre módulos - Use injeção de dependência para reduzir o acoplamento - Documente claramente as dependências do módulo - Evite dependências circulares ### Tratamento de erros - Trate erros no nível apropriado - Use exceções para condições excepcionais - Forneça mensagens de erro significativas - Não engula exceções sem um bom motivo ## Diretrizes específicas da linguagem ### JavaScript/TypeScript - Siga o guia de estilo do Airbnb JavaScript - Use recursos ES6+ quando apropriado - Use TypeScript para segurança de tipos - Prefira padrões de programação funcional ```javascript // Prefira const em vez de let quando a variável não for reatribuída const PI = 3.14159; // Use literais de modelo para interpolação de string const greeting = `Hello, ${name}!`; // Use atribuição de desestruturação const { firstName, lastName } = user; // Use funções de seta para retornos de chamada curtos const doubled = numbers.map(n =&gt; n * 2); ``` ### Python - Siga o guia de estilo PEP 8 - Use dicas de tipo (PEP 484) - Prefira compreensões de lista/dicionário para casos simples - Use gerenciadores de contexto para gerenciamento de recursos ```python # Use compreensões de lista para transformações simples doubled = [n * 2 for n in numbers] # Use gerenciadores de contexto para gerenciamento de recursos with open(&quot;file.txt&quot;, &quot;r&quot;) as f: content = f.read() # Use dicas de tipo def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; ``` ### HTML/CSS - Use elementos HTML semânticos - Siga a metodologia BEM para classes CSS - Minimize estilos inline - Use variáveis CSS para temas ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title"> Título</h2></header><div class="card__content"><p> O conteúdo vai aqui</p></div></article> ``` ```css /* Use variáveis CSS para temas */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* Siga a metodologia BEM */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## Controle de versão ### Mensagens de commit - Escreva mensagens de commit claras e descritivas - Use o modo imperativo (&quot;Adicionar recurso&quot;, não &quot;Recurso adicionado&quot;) - Faça referência aos números de problemas quando aplicável - Siga o formato convencional de commits ``` feat: adicione um sistema de autenticação de usuário - Implemente autenticação baseada em JWT - Adicione endpoints de login e registro - Crie um middleware de autenticação Fecha #123 ``` ### Estratégia de ramificação - Use branches de recursos para novos desenvolvimentos - Mantenha o branch principal/mestre estável - Use pull requests para revisão de código - Exclua branches após a mesclagem ### Revisões de código - Revise todo o código antes da mesclagem - Foco na arquitetura, segurança e desempenho - Seja construtivo e respeitoso nos comentários - Use ferramentas automatizadas para detectar problemas de estilo ## Conclusão Este guia de estilo foi criado para garantir consistência e qualidade em toda a base de código WhytCard. Embora abranja princípios gerais, consulte os guias específicos da linguagem para regras mais detalhadas. Lembre-se de que o objetivo é criar um código sustentável, legível e robusto. Espera-se que todos os membros da equipe sigam essas diretrizes e ajudem a aplicá-las por meio de revisões de código e mentoria. --- Última atualização: 2025-01-15 