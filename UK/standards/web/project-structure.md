# Стандарти структури проекту 

## Організація каталогів 

### Коренева структура 

``` 
project-root/ 
├── src/ # Вихідний код 
├── public/ # Статичні ресурси 
├── dist/ # Вихідні дані збірки (згенеровані) 
├── node_modules/ # Залежності (згенеровані) 
├── tests/ # Тестові файли 
├── docs/ # Документація 
├── .github/ # Робочі процеси та шаблони GitHub 
├── .vscode/ # Конфігурація VS Code 
├── scripts/ # Скрипти збірки та утиліт 
├── package.json # Метадані та залежності проекту 
├── tsconfig.json # TypeScript конфігурація 
├── .eslintrc.js # Конфігурація ESLint 
├── .prettierrc # Конфігурація Prettier 
├── .gitignore # Шаблони ігнорування Git 
├── .env.example # Приклад змінних середовища 
└── README.md # Документація проекту 
``` 

### Структура вихідного каталогу 

``` 
src/ 
├── assets/ # Статичні ресурси, що потребують обробки 
│ ├── images/ # Зображення 
│ ├── fonts/ # Файли шрифтів 
│ └── styles/ # Глобальні стилі 
│ 
├── components/ # Компоненти інтерфейсу користувача, що можуть бути повторно використані 
│ ├── common/ # Спільні компоненти для різних функцій 
│ ├── layout/ # Компоненти макета 
│ └── ui/ # Базові компоненти інтерфейсу користувача 
│ 
├── hooks/ # Користувацькі React hooks 
│ 
├── pages/ # Компоненти сторінки / компоненти маршруту 
│ 
├── features/ # Модулі на основі функцій 
│ ├── feature1/ # Специфічна функція 
│ │ ├── components/ # Компоненти, специфічні для функції 
│ │ ├── hooks/ # Гачки, специфічні для функції 
│ │ ├── api/ # Виклики API, специфічні для функції 
│ │ ├── utils/ # Утиліти, що відповідають певним функціям 
│ │ ├── types/ # Типи, що відповідають певним функціям 
│ │ └── index.ts # Експорт функцій 
│ └── feature2/ # Інша функція 
│ 
├── services/ # Інтеграція сервісів 
│ ├── api/ # Клієнт API та кінцеві точки 
│ ├── auth/ # Служба автентифікації 
│ └── analytics/ # Служба аналітики 
│ 
├── store/ # Керування станом 
│ ├── slices/ # Зрізи Redux або постачальники контексту 
│ ├── actions/ # Дія творці 
│ └── селектори/ # Селектори станів 
│ 
├── утиліти/ # Допоміжні функції 
│ ├── форматування/ # Утиліти форматування 
│ ├── валідація/ # Утиліти валідації 
│ └── допоміжні функції/ # Допоміжні функції 
│ 
├── типи/ # Визначення типів TypeScript 
│ ├── api/ # Типи відповідей API 
│ ├── моделі/ # Типи моделей даних 
│ └── common/ # Загальні визначення типів 
│ 
├── константи/ # Константи застосунку 
│ 
├── i18n/ # Інтернаціоналізація 
│ ├── locales/ # Файли перекладу 
│ └── config.ts # Конфігурація i18n 
│ 
├── config/ # Конфігурація програми 
│ ├── routes.ts # Визначення маршрутів 
│ └── settings.ts # Налаштування програми 
│ 
└── App.tsx # Головний компонент програми 
``` 

## Правила іменування 

### Файли та каталоги 

- **Компоненти React**: PascalCase з розширенням 
- `Button.tsx`, `UserProfile.tsx` 
- **Хуки**: camelCase з префіксом 'use' 
- `useAuth.ts`, `useFetch.ts` 
- **Утиліти**: camelCase 
- `formatDate.ts`, `validateEmail.ts` 
- **Константи**: UPPER_SNAKE_CASE 
- `API_ENDPOINTS.ts`, `ROUTE_PATHS.ts` 
- **Типи/Інтерфейси**: PascalCase з описовими назвами 
- `UserData.ts`, `ApiResponse.ts` 
- **Тестові файли**: Те саме ім'я, що й у тестованого файлу, з суфіксом `.test` або `.spec` 
- `Button.test.tsx`, `formatDate.spec.ts` 

### Організація компонентів 

- **Файли компонентів**: Один компонент на файл 
- **Структура компонента**: 
```tsx 
// Імпорт 
import React from 'react'; 
import './styles.css'; 

// Типи 
interface ButtonProps { 
// ... 
} 

// Компонент 
export const Button: React.FC<ButtonProps> = ({ children, ...props }) => { 
// ... 
return ( 
// JSX 
); 
}; 

// Допоміжні функції, специфічні для цього компонента 
const helperFunction = () => { 
// ... 
}; 
``` 

## Організація модулів 

### Порядок імпорту 

1. Зовнішні бібліотеки 
2. Внутрішні модулі 
3. Компоненти 
4. Хуки 
5. Утиліти 
6. Типи 
7. Ресурси/стилі 

Приклад: 
```tsx 
// Зовнішні бібліотеки 
import React, { useState, useEffect } from 'react'; 
import { useNavigate } from 'react-router-dom';

// Внутрішні модулі 
import { API_ENDPOINTS } from '@/constants/api'; 
import { fetchData } from '@/services/api'; 

// Компоненти 
import { Button } from '@/components/ui'; 
import { Modal } from '@/components/common'; 

// Хуки 
import { useAuth } from '@/hooks'; 

// Утиліти 
import { formatDate } from '@/utils/formatting'; 

// Типи 
import type { UserData } from '@/types'; 

// Ресурси/стилі 
import './styles.css'; 
``` 

### Шаблони експорту

- Використовуйте іменовані експорти для більшості компонентів та функцій
- Використовуйте експорт бочок (index.ts) для спрощення імпорту
- Уникайте експорту за замовчуванням, окрім компонентів сторінки

Приклад експорту бочки: 
```tsx 
// components/ui/index.ts 
export * from './Button'; 
export * from './Input'; 
export * from './Card'; 
``` 

## Файли конфігурації 

### Змінні середовища 

- Використовуйте файли `.env` для конфігурації, що залежить від середовища 
- Включіть `.env.example` до документації 
- Використовуйте файли, що відповідають певному середовищу (`.env.development`, `.env.production`) 
- Ніколи не передавайте конфіденційні значення до системи контролю версій 

### Конфігурація TypeScript 

- Використовуйте суворий режим 
- Налаштуйте псевдоніми шляхів для чистішого імпорту 
- За потреби окремими конфігураціями для різних середовищ 
- Документуйте неочевидні варіанти конфігурації 

### Керування пакетами 

- Використовуйте файл блокування (package-lock.json, yarn.lock, pnpm-lock.yaml) 
- Документуйте необхідну версію Node.js 
- Логічно групуйте залежності в package.json 
- Відокремте залежності dev від залежностей production 

## Документація 

### Документація коду 

- Документуйте складні функції та компоненти 
- Використовуйте JSDoc для документації функцій 
- Документуйте властивості компонентів React 
- Включіть приклади для повторного використання компоненти 
- Шаблони керування станом документації 

### Документація проекту 

- Включити вичерпний файл README.md 
- Процес налаштування та встановлення документа 
- Включити інструкції щодо робочого процесу розробки 
- Процес створення та розгортання документа 
- Ведення CHANGELOG.md для історії версій 
- Включити рекомендації щодо внесення змін 

## Найкращі практики 

- Групування пов'язаних файлів разом 
- Зберігання файлів компонентів невеликими та цілеспрямованими 
- Відокремлення бізнес-логіки від компонентів інтерфейсу користувача 
- Використовування псевдонімів шляхів, щоб уникнути глибоких шляхів імпорту 
- Підтримка послідовної організації файлів у всьому проекті 
- Документування структури проекту для нових членів команди 
- Використовування генераторів коду для узгодженості, коли це можливо 
- Періодично переглядати та рефакторувати структуру проекту