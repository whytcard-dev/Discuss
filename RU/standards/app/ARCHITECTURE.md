# Глобальная архитектура WhytCard 

## Введение 

В этом документе представлена глобальная архитектура проекта WhytCard, платформы веб-скрейпинга и обучения ИИ с открытым исходным кодом. Архитектура разработана как модульная, масштабируемая и поддерживаемая, что позволяет легко добавлять новые функции, обеспечивая при этом стабильность системы. 

## Обзор 

WhytCard организован в соответствии с архитектурой клиент-сервер с четким разделением между фронтендом и бэкендом. Такое разделение обеспечивает независимую эволюцию обоих компонентов и облегчает командную работу. 

``` 
┌──────────────────┐ ┌───────────────────┐ 
│ │ │ │ 
│ Фронтенд │◄────►│ Бэкенд │ 
│ (Vue.js) │ │ (FastAPI) │ 
│ │ │ │ 
└──────────────────┘ └────────────────────┘ 
▲ 
│ 
▼ 
┌───────────────────┐ 
│ │ 
│ Скрапинг и │ 
│ Конвейер данных │ 
│ │ 
└─────────────────┘ 
▲ 
│ 
▼ 
┌───────────────────┐ 
│ │ 
│ Хранение │ 
│ │ 
└───────────────────┘ 
``` 

## Главное Компоненты 

### 1. Фронтенд (Vue.js) 

Фронтенд разработан с помощью Vue.js и использует Tailwind CSS для стилизации. Он отвечает за пользовательский интерфейс и пользовательский опыт. 

#### Основные характеристики 

- **Фреймворк**: Vue.js 3 с Composition API 
- **Стилизация**: Tailwind CSS 
- **Анимации**: Framer Motion 
- **Интернационализация**: i18next с автоматическим определением языка браузера 
- **Маршрутизация**: Vue Router 
- **Управление состоянием**: Pinia 

#### Структура 

``` 
src/ 
├── components/ # Повторно используемые компоненты 
├── config/ # Конфигурация фронтенда 
├── i18n/ # Файлы перевода 
├── router/ # Конфигурация маршрута 
├── views/ # Главные страницы 
└── main.js # Точка входа 
``` 

### 2. Бэкенд (FastAPI) 

Бэкенд разработан с использованием FastAPI, современной и высокопроизводительной среды Python для создания API. Он обрабатывает все операции сервера, доступ к данным и бизнес-логику. 

#### Основные характеристики 

- **Фреймворк**: FastAPI 
- **Аутентификация**: JWT 
- **Валидация**: Pydantic 
- **Документация API**: Интегрированный пользовательский интерфейс Swagger 

#### Структура 

``` 
backend/ 
├── config/ # Конфигурация бэкенда 
├── core/ # Основная бизнес-логика 
│ ├── api/ # Конечные точки API 
│ └── schemas/ # Схемы Pydantic 
├── models/ # Модели данных 
├── utils/ # Утилиты 
└── main.py # Точка входа 
``` 

### 3. Скрапинг & Data Pipeline 

Этот модуль отвечает за сбор данных из веб-источников и их преобразование для обучения модели ИИ. 

#### Основные характеристики 

- **Скрапинг**: асинхронная система с aiohttp и BeautifulSoup 
- **Оркестровка**: управление задачами и приоритетами 
- **Преобразование**: очистка и нормализация данных 
- **Кэш**: система кэширования для избежания избыточных запросов 

#### Структура 

``` 
backend/ 
├── scraping/ 
│ ├── scrapers/ # Конкретные реализации для разных источников 
│ ├── utils/ # Утилиты для скрапинга 
│ ├── orchestrator.py # Оркестратор задач 
│ └── cache.py # Система кэширования 
└── datasets/ # Собранные и преобразованные данные 
``` 

### 4. Хранилище 

Хранилище система управляет сохранением данных и доступом к ним. 

#### Варианты хранения 

- **База данных**: PostgreSQL для структурированных данных 
- **Хранилище файлов**: Локальная файловая система или совместимая с S3 для больших данных 
- **Кэш**: Redis для распределенного кэша 

## Поток данных 

### 1. Сбор данных 

``` 
┌──────────────┐ ┌──────────────┐ ┌───────────────┐ 
│ │ │ │ │ │ 
│ Веб │────►│ Скребки │────►│ Кэш │ 
│ Источники │ │ │ │ │ 
└──────────────┘ └──────────────┘ └───────────────┘ 
│ 
▼ 
┌──────────────┐ ┌──────────────┐ 
│ │ │ │ 
│ Процессоры │────►│ Хранилище │ 
│ │ │ │ 
└──────────────┘ └─────────────┘ 
``` 

1. Скребки собирают данные из веб-источников 
2. Данные кэшируются, чтобы избежать избыточных запросов 
3. Процессоры очищают и преобразуют данные 
4. Преобразованные данные сохраняются для последующего использования 

### 2. Обучение модели 

``` 
┌──────────────┐ ┌──────────────┐ ┌──────────────┐ 
│ │ │ │ │ │ 
│ Наборы данных │────►│ Препроцессор│────►│ Обучение │ 
│ │ │ │ │ │ 
└──────────────┘ └─────────────┘ └───────────────┘ 
│ 
▼ 
┌─────────────┐ 
│ │ 
│ Модели │ 
│ │ 
└───────────────┘ 
``` 

1. Наборы данных — это извлекаются из хранилища 
2. Данные предварительно обрабатываются для обучения 
3. Модели обучаются на предварительно обработанных данных 
4. Обученные модели сохраняются 

### 3. Использование модели 

``` 
┌─────────────┐ ┌──────────────┐ ┌──────────────┐ 
│ │ │ │ │ │ 
│ API │────►│ Модели │────►│ Ответ │ 
│ Запрос │ │ │ │ │ 
└─────────────┘ └──────────────┘ └────────────────┘ 
``` 

1. Получен запрос API 
2. Для обработки запроса используются соответствующие модели запрос 
3. Генерируется и возвращается ответ 

## Связь между компонентами 

### REST API 

Связь между фронтендом и бэкендом осуществляется в основном через REST API. Конечные точки логически организованы и документированы с помощью Swagger UI. 

### WebSockets 

Для функций, требующих обновлений в реальном времени (например, отслеживание задач по скрапингу), используются WebSockets для обеспечения двунаправленной связи. 

### Очередь сообщений 

Для асинхронных и длительных задач используется очередь сообщений (например, RabbitMQ или Redis Pub/Sub) для разделения компонентов и обеспечения надежности. 

## Развертывание 

### Варианты развертывания 

WhytCard можно развернуть несколькими способами: 

1. **Настольное приложение**: использование Tauri для создания кроссплатформенного настольного приложения 
2. **Облачное развертывание**: развертывание в облачных сервисах, таких как AWS, GCP или Azure 
3. **Самостоятельное размещение**: установка на персональном или корпоративном сервере 

### Архитектура развертывания 

``` 
┌───────────────────┐ ┌───────────────────┐ 
│ │ │ │ 
│ Фронтенд │◄────►│ API-шлюз │ 
│ (Статический) │ │ │ 
└───────────────────┘ └────────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ 
│ │ 
│ API бэкэнда │ 
│ │ 
└────────────────────┘ 
▲ 
│ 
▼ 
┌───────────────────┐ ┌──────────────────┐ 
│ │ │ │ 
│ База данных │ │ Хранилище файлов │ 
│ │ │ │ 
└──────────────────┘ └────────────────────┘ 
``` 

## Безопасность 

### Принципы безопасности 

1. **Глубокая защита**: Несколько уровней безопасности 
2. **Принцип наименьших привилегий**: Минимально необходимый доступ 
3. **Проверка ввода**: Все пользовательские входные данные проверяются 
4. **Защита данных**: Шифрование конфиденциальных данных 

### Меры безопасности 

- **Аутентификация**: JWT с ротацией токенов 
- **Авторизация**: Управление доступом на основе ролей 
- **Защита от распространенных атак**: XSS, CSRF, SQL-инъекция 
- **Аудит**: Регистрация важных действий 

## Масштабируемость 

Архитектура разработана для горизонтального и вертикального масштабирования: 

- **Микросервисы**: Компоненты могут быть развернуты независимо 
- **Кэширование**: Использование многоуровневых кэшей 
- **Балансировка нагрузки**: Распределение трафика между несколькими экземплярами 
- **Разделение**: разделение данных для повышения производительности 

## Мониторинг и наблюдение 

- **Ведение журнала**: централизованное ведение журнала с помощью ELK Stack или эквивалента 
- **Метрики**: сбор метрик с помощью Prometheus 
- **Трассировка**: отслеживание запросов с помощью OpenTelemetry 
- **Оповещения**: оповещения на основе предопределенных пороговых значений 

## Заключение 

Архитектура WhytCard разработана так, чтобы быть надежной, масштабируемой и обслуживаемой. Четкое разделение обязанностей между различными компонентами обеспечивает независимую эволюцию и облегчает командную работу. Выбор технологий был сделан с учетом текущих и будущих потребностей проекта, а также передовых отраслевых практик. 

Эта архитектура будет регулярно пересматриваться и обновляться для адаптации к новым потребностям и технологическим разработкам. 

--- 

Последнее обновление: 2025-01-15