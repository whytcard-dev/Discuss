# Guide de style général pour WhytCard ## Introduction Ce document définit le style de codage général et les bonnes pratiques à suivre pour tous les langages et technologies utilisés dans le projet WhytCard. Ces normes garantissent la cohérence, la maintenabilité et la qualité de l&#39;ensemble du code. ## Table des matières 1. [Principes fondamentaux](#principes-fondamentaux) 2. [Conventions de nommage](#conventions-de-nommage) 3. [Formatage](#formatage) 4. [Documentation](#documentation) 5. [Structure du code](#structure-du-code) 6. [Directives spécifiques au langage](#directives-spécifiques-au-langage) 7. [Contrôle de version](#contrôle-de-version) ## Principes fondamentaux ### Clarté plutôt qu&#39;ingéniosité Privilégiez toujours la clarté du code plutôt que les solutions astucieuses ou complexes : - Écrivez du code facile à comprendre - Évitez les fonctionnalités de langage obscures sauf si nécessaire - Privilégiez la lisibilité et la maintenabilité à la concision ### Cohérence Maintenez la cohérence dans l&#39;ensemble de la base de code : - Suivez les modèles établis dans le projet - Ne mélangez pas différents styles ou approches - Lorsque vous modifiez du code existant, respectez son style ### DRY (Ne vous répétez pas) Évitez la duplication de code : - Extrayez le code répété dans des fonctions ou des classes - Créez Utilitaires partagés pour les opérations courantes - Utiliser l&#39;héritage ou la composition pour partager le comportement ### KISS (Keep It Simple, Stupid) Préférez les solutions simples aux solutions complexes : - Commencez par l&#39;approche la plus simple qui fonctionne - Ajoutez de la complexité uniquement lorsque c&#39;est nécessaire - Décomposez les problèmes complexes en parties plus simples ### YAGNI (You Aren&#39;t Gonna Need It) N&#39;ajoutez pas de fonctionnalités tant que ce n&#39;est pas nécessaire : - Évitez les fonctionnalités spéculatives - Implémentez uniquement ce qui est requis maintenant - Refactorisez lorsque c&#39;est nécessaire, pas de manière préventive ## Conventions de nommage ### Règles générales - Les noms doivent être descriptifs et transmettre un objectif - Utilisez des mots complets plutôt que des abréviations (sauf pour les mots courants) - Soyez cohérent avec les modèles de nommage existants ### Styles de casse Utilisez le style de casse approprié pour chaque langage : - **camelCase** : variables et fonctions JavaScript/TypeScript - **PascalCase** : classes dans la plupart des langages, composants React - **snake_case** : variables et fonctions Python - **kebab-case** : éléments HTML, classes CSS, noms de fichiers - **UPPER_SNAKE_CASE** : constantes dans la plupart langues ### Exemples de nommage ```javascript // JavaScript const userProfile = { firstName: &#39;John&#39;, lastName: &#39;Doe&#39;, EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculateTotalPrice(items) { // Implémentation } class UserManager { // Implémentation } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculate_total_price(items): # Passe d&#39;implémentation class UserManager: # Passe d&#39;implémentation ``` ## Formatage ### Indentation - Utilisez une indentation cohérente dans tout le projet - Pour JavaScript/TypeScript/HTML/CSS : 2 espaces - Pour Python : 4 espaces (PEP 8) - Ne mélangez jamais les tabulations et les espaces ### Longueur de ligne - Limitez les lignes à un maximum de 100 caractères pour la plupart des langages - Pour Python, suivez la PEP 8 (79 caractères pour le code, 72 pour les commentaires) - Coupez les longues lignes d&#39;une manière naturelle pour le langage ### Espacement - Utilisez des espaces autour des opérateurs - Utilisez des espaces après virgules et points-virgules - Utiliser un espacement cohérent dans les appels de fonction et les déclarations ### Crochets et blocs - Crochets ouvrants sur la même ligne pour la plupart des langages (à l&#39;exception des fonctions et classes Python) - Utilisation cohérente des crochets, même pour les blocs d&#39;une seule ligne - Aligner les crochets fermants avec le début de la ligne d&#39;ouverture ### Exemples ```javascript // JavaScript function calculateDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculate_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Item 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Item 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Item 3&quot;, &quot;price&quot;: 30}, ] ``` ## Documentation ### Commentaires sur le code - Utilisez les commentaires pour expliquer « pourquoi », pas « quoi » - Commentez les algorithmes complexes ou les solutions non évidentes - Gardez les commentaires à jour avec les changements de code - Évitez les commentaires redondants ou évidents ### Documentation des fonctions et des méthodes Documentez toutes les fonctions et méthodes avec : - Description de l&#39;objectif - Paramètres et leurs types - Valeur de retour et type - Exceptions qui peuvent être levées - Exemples d&#39;utilisation pour les fonctions complexes ### En-têtes de fichier Inclure au début de chaque fichier : - Brève description de l&#39;objectif du fichier - Informations sur l&#39;auteur(s) - Date de création - Informations sur la licence ### Exemples ```javascript /** * Calcule le prix total des articles après application des remises. * * @param {Array<Object> } items - Tableau d&#39;objets item avec propriété price * @param {number} discountPercent - Pourcentage de remise (0-100) * @returns {number} Prix total après remise * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculateTotalPrice(items, 10); // Renvoie 27 */ function calculateTotalPrice(items, discountPercent) { // Implémentation } ``` ```python def calculate_total_price(items, discount_percent): &quot;&quot;&quot; Calcule le prix total des articles après application des remises. Args: items: Liste des dictionnaires avec la propriété price discount_percent: Pourcentage de remise (0-100) Renvoie: float: Prix total après remise Exemple: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculate_total_price(items, 10) # Renvoie 27 &quot;&quot;&quot; # Implémentation ``` ## Structure du code ### Organisation des fichiers - Une classe/un composant principal par fichier - Regrouper les fonctionnalités liées dans le même répertoire - Séparer l&#39;interface de l&#39;implémentation lorsque cela est approprié - Garder les fichiers de taille raisonnable (&lt; 500 lignes à titre indicatif) ### Taille des fonctions et des méthodes - Garder les fonctions et les méthodes petites et ciblées - Visez des fonctions qui font bien une chose - Limiter la longueur des fonctions (&lt; 50 lignes à titre indicatif) guideline) - Extraire la logique complexe dans les fonctions d&#39;aide ### Gestion des dépendances - Minimiser les dépendances entre les modules - Utiliser l&#39;injection de dépendances pour réduire le couplage - Documenter clairement les dépendances des modules - Éviter les dépendances circulaires ### Gestion des erreurs - Gérer les erreurs au niveau approprié - Utiliser des exceptions pour les conditions exceptionnelles - Fournir des messages d&#39;erreur significatifs - Ne pas avaler les exceptions sans bonne raison ## Directives spécifiques au langage ### JavaScript/TypeScript - Suivre le guide de style JavaScript d&#39;Airbnb - Utiliser les fonctionnalités ES6+ lorsque cela est approprié - Utiliser TypeScript pour la sécurité des types - Préférer les modèles de programmation fonctionnels ```javascript // Préférer const à let lorsque la variable ne sera pas réaffectée const PI = 3.14159; // Utiliser des littéraux de modèle pour l&#39;interpolation de chaîne const greeting = `Hello, ${name}!`; // Utiliser l&#39;affectation de déstructuration const { firstName, lastName } = user; // Utiliser les fonctions fléchées pour les rappels courts const doubled = numbers.map(n =&gt; n * 2); ``` ### Python - Suivez le guide de style PEP 8 - Utilisez les conseils de type (PEP 484) - Préférez les compréhensions de liste/dict pour les cas simples - Utilisez les gestionnaires de contexte pour la gestion des ressources ```python # Utilisez les compréhensions de liste pour les transformations simples doubled = [n * 2 pour n dans les nombres] # Utilisez les gestionnaires de contexte pour la gestion des ressources with open(&quot;file.txt&quot;, &quot;r&quot;) as f: content = f.read() # Utilisez les conseils de type def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; ``` ### HTML/CSS - Utilisez des éléments HTML sémantiques - Suivez la méthodologie BEM pour les classes CSS - Minimisez les styles en ligne - Utilisez les variables CSS pour la thématisation ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title"> Titre</h2></header><div class="card__content"><p> Le contenu va ici</p></div></article> ``` ```css /* Utiliser les variables CSS pour la thématisation */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* Suivre la méthodologie BEM */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## Contrôle de version ### Messages de validation - Rédigez des messages de validation clairs et descriptifs - Utilisez le mode impératif (« Ajouter une fonctionnalité » et non « Fonctionnalité ajoutée ») - Référencez les numéros de problème le cas échéant - Suivez le format de validation conventionnel ``` feat : ajouter un système d&#39;authentification des utilisateurs - Implémenter l&#39;authentification basée sur JWT - Ajouter des points de terminaison de connexion et d&#39;enregistrement - Créer un middleware d&#39;authentification Ferme #123 ``` ### Stratégie de ramification - Utilisez les branches de fonctionnalités pour le nouveau développement - Gardez la branche principale/maîtresse stable - Utilisez les demandes d&#39;extraction pour la révision du code - Supprimer les branches après la fusion ### Revues de code - Examinez tout le code avant la fusion - Concentrez-vous sur l&#39;architecture, la sécurité et les performances - Soyez constructif et respectueux dans les commentaires - Utilisez des outils automatisés pour détecter les problèmes de style ## Conclusion Ce guide de style est conçu pour assurer la cohérence et la qualité de la base de code WhytCard. Bien qu&#39;il couvre les principes généraux, reportez-vous aux guides spécifiques au langage pour des règles plus détaillées. N&#39;oubliez pas que l&#39;objectif est de créer un code maintenable, lisible et robuste. Tous les membres de l&#39;équipe sont censés suivre ces directives et contribuer à leur application par le biais de revues de code et de mentorat. --- Dernière mise à jour : 2025-01-15 