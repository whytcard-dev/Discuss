# コード品質基準

## コア原則

- クリーンで保守性が高く、自己文書化可能なコードを書く
- SOLID原則とDRY原則に従う
- 関数は小さく、焦点を絞ったものにする（単一責任）
- 変数、関数、クラスには説明的な名前を付ける
- プロジェクト全体で一貫したコードスタイルを維持する
- 複雑なロジックと公開APIをドキュメント化する
- 機械だけでなく、人間のためにコードを書く

## JavaScript/TypeScript標準

### TypeScriptの設定

- strictモードを使用する（`"strict": true`）
- 推奨されるすべての型チェックオプションを有効にする
- 適切なモジュール解決を設定する
- 適切なターゲットECMAScriptバージョンを設定する
- include/excludeパターンを指定する
- よりクリーンなインポートのためにパスエイリアスを使用する

### 命名規則

- **変数/関数**: camelCase (`getUserData`, `calculateTotal`)
- **クラス/インターフェース/型**: PascalCase (`UserProfile`, `ApiResponse`)
- **定数**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`, `API_URL`)
- **プライベートプロパティ**: `#` プレフィックスまたは `_` 表記規則を使用する (`#privateField`, `_privateMethod`)
- **ブール変数**: "is", "has", "can" プレフィックスを使用する (`isActive`, `hasPermission`)
- **コンポーネントファイル**: 拡張子付き PascalCase (`UserCard.tsx`)
- **ユーティリティファイル**: 拡張子付き camelCase (`formatDate.ts`)

### コード構成

- ファイルごとに 1 つのクラス/コンポーネント
- 外部/内部のインポートをグループ化する
- インポートをアルファベット順に並べる
- バレルエクスポートを使用する関連機能については、(`index.ts`) を参照してください。
- コードを機能/モジュール別に整理する
- ファイルを 400 行以下にする（それより大きい場合は分割する）
- 関数は 50 行以下にする
- ネストの最大レベル：3～4 レベル

### ベストプラクティス

- 不変性（const、readonly、Object.freeze）を優先する
- オプショナルチェインと null 合体を使用する
- 適切なエラー処理を実装する
- 必要な場合を除き、型の使用を避ける
- 実行時の型チェックには型ガードを使用する
- 生の promise よりも async/await を優先する
- マジックナンバーと文字列は避ける（定数を使用する）
- 適切な null/undefined チェックを実装する
- ネストを減らすために早期リターンを使用する

## React 標準

### コンポーネント構造

- フック付きの関数型コンポーネントを優先する
- コンポーネントには名前付きエクスポートを使用する
- TypeScript でプロパティ検証を実装する
- 複雑なロジックはカスタムフックに抽出する
- コンポーネントはUI に関する懸念事項に重点を置く
- 適切なエラー境界を実装する
- パフォーマンス最適化のために React.memo を使用する
- 再利用可能なコンポーネントを抽出する

### 状態管理

- コンポーネント固有のデータにはローカル状態を使用する
- コンポーネント間で共有される状態にはコンテキストを使用する
- 複雑なアプリでは外部状態管理を検討する
- 状態を正規化し最小限に抑える
- 適切な状態初期化を実装する
- 複雑な状態ロジックにはリデューサーを使用する
- プロパティのドリルダウンを避ける（コンポジションまたはコンテキストを使用する）

### パフォーマンス最適化

- 純粋なコンポーネントには React.memo を使用する
- 高価な計算には useMemo を実装する
- 関数のメモ化には useCallback を使用する
- 長いリストを仮想化する（react-window、react-virtualized）
- フックに適切な依存関係配列を実装する
- 不要な再レンダリングを避ける
- React Profiler を使用してボトルネックを特定する

## テスト標準

### ユニットテスト

- すべてのビジネスロジックとユーティリティをテストする
- 使用するJest または Vitest をテストランナーとして使用する
- 依存関係の適切なモックを実装する
- コンポーネントテストにはテストライブラリを使用する
- AAA パターン (Arrange, Act, Assert) に従う
- 説明的なテスト名を付ける
- コードカバレッジ 80% 以上を目指す
- エッジケースとエラーシナリオをテストする

### 統合テスト

- コンポーネントのインタラクションをテストする
- フォーム送信とユーザーフローをテストする
- API モックには MSW を使用する
- ルーティングとナビゲーションをテストする
- 状態の変化を確認する
- 現実的なデータでテストする

### エンドツーエンドテスト

- Cypress または Playwright を使用する
- 重要なユーザージャーニーをテストする
- 複数のブラウザでテストする
- 適切なテスト分離を実装する
- テストセレクタにデータ属性を使用する
- 不安定なテストには再試行ロジックを実装する
- アクセシビリティをテストする

## コードレビュー基準

### プロセス

- マージ前にすべてのコードをレビューする必要がある
- 自動チェックレビュー前に必ずパスする
- プルリクエストテンプレートを使用する
- PRは小さく、焦点を絞る
- レビューコメントには迅速に対応する
- マージ前にすべてのコメントを解決する
- マージ前にコミットをスカッシュする

### レビューチェックリスト

- コードはプロジェクト標準に準拠している
- テストが含まれており、パスしている
- ドキュメントが更新されている
- セキュリティ上の脆弱性がない
- パフォーマンスへの影響を考慮している
- アクセシビリティ要件を満たしている
- エッジケースが処理されている
- 不要なコードや依存関係がない

## ツール

### リンティングとフォーマット

- 適切なルールを持つESLint
- 一貫したフォーマットのためのPrettier
- コミット前のフックのためのHusky
- インクリメンタルリンティングのためのlint-staged
- 型チェックのためのTypeScriptコンパイラ
- CSS/SCSSのためのStylelint

### 静的解析

- SonarQubeまたはCodeClimate
- 複雑度メトリクスの監視
- 重複コード検出
- セキュリティ脆弱性スキャン
- バンドルサイズ分析
- 未使用コード検出

### CI/CD 統合

- すべての PR ですべてのチェックを実行
- チェックに失敗した場合、マージをブロック
- テストカバレッジレポートを生成して公開
- パフォーマンス回帰テストを実装
- 依存関係の更新を自動化
- プレビュー環境をデプロイ