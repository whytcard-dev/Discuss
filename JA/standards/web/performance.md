# ウェブパフォーマンス標準

## パフォーマンス目標

- Lighthouse スコア：すべての指標で 90 以上
- Core Web Vitals 目標：
- LCP（最大コンテンツペイント）：2.5 秒未満
- FID（初回入力遅延）：100 ミリ秒未満
- CLS（累積レイアウトシフト）：0.1 未満
- INP（インタラクションから次のペイントまで）：200 ミリ秒未満
- インタラクティブになるまでの時間：3 秒未満
- 初回コンテンツペイント：1.8 秒未満
- ページの総容量：1 MB 未満（理想的には 500 KB 未満）
- HTTP リクエスト：1 ページあたり 50 件未満

## 画像の最適化

- WebP/AVIF 形式を使用し、古いブラウザにはフォールバック機能を使用する
- `srcset` 属性と `sizes` 属性を使用してレスポンシブ画像を実装する
- スクロールダウン下の画像は遅延読み込みする
- 画像のサイズを適切に調整する（不要な画像の表示を避ける）大きな画像はCSSで縮小する
- 可能な場合は画像CDNを使用して動的にサイズ変更する
- SVGを最適化し、不要なメタデータを削除する
- ImageOptim、TinyPNG、Squooshなどのツールを使用してすべての画像を圧縮する
- プログレッシブロードにはブラーアップ手法を検討する

## JavaScriptの最適化

- コード分割と動的インポートを実装する
- 重要でないJavaScriptを遅延させる
- ツリーシェイキングを使用してデッドコードを削除する
- JavaScriptファイルを縮小して圧縮する
- レンダリングをブロックするJavaScriptを避ける
- CPU負荷の高いタスクにはWebワーカーを使用する
- リクエストの優先順位付けを実装する
- サードパーティのスクリプトを最適化し、async/defer属性を使用する

## CSSの最適化

- 重要なCSSを最小化しインライン化する
- PurgeCSSなどのツールを使用して未使用のCSSを削除する
- CSSインポートを避ける（代わりに連結を使用する）
- 独立したコンポーネントにはCSS包含を使用する
- CSSセレクタを最適化するパフォーマンス
- CSS-in-JS のパフォーマンスへの影響を考慮する
- 保守性を向上させるために CSS 変数を使用する
- 大規模アプリケーションでは CSS コード分割を実装する

## フォントの最適化

- 可能な場合はシステムフォントを使用する
- font-display: swap または optional を実装する
- 必要な文字のみを含むようにフォントをサブセット化する
- サードパーティのサービスではなく、フォントを自己ホストする
- 重要なフォントをプリロードする
- 複数のウェイト/スタイルに対応する可変フォントを使用する
- フォントのバリエーション（ウェイト、スタイル）を制限する

## キャッシュ戦略

- 効果的なキャッシュポリシーを実装する
- 静的アセットのキャッシュ期間を長くする（1年以上）
- HTML のキャッシュ期間を短くする/しない
- キャッシュ無効化のためにバージョン管理されたファイル名またはクエリ文字列を使用する
- オフラインサポートのためにサービスワーカーを実装する
- クライアントサイドのキャッシュには localStorage/IndexedDB を使用する
- HTTP キャッシュヘッダーを適切に構成する
- CDN キャッシュを実装する

## サーバー最適化

- HTTP/2 または HTTP/3 を有効にする
- サーバーサイド圧縮 (Brotli/Gzip) を実装する
- グローバルコンテンツ配信に CDN を使用する
- API レスポンスを最適化する (ページネーション、フィールド選択)
- 動的コンテンツ向けにエッジコンピューティングを実装する
- 適切な CORS 設定を構成する
- 最初のバイトまでの時間 (TTFB) を最適化する
- HTTP の事前接続、プリフェッチ、および事前ロードのヒントを使用する

## モバイル最適化

- モバイルパフォーマンスを優先する (モバイルファーストのアプローチ)
- タッチターゲットを最適化する (最小 44×44 ピクセル)
- モバイルデバイスのネットワークペイロードを削減する
- レスポンシブデザインパターンを実装する
- エミュレータだけでなく、実際のモバイルデバイスでテストする
- アニメーションのモーションを減らすことを検討する
- オフライン/接続状態が悪いシナリオ向けに最適化する

## モニタリングとテスト

- リアルユーザーモニタリング (RUM) を実装する
- 重要なユーザーフローに対して合成モニタリングを設定する
- 詳細なパフォーマンスには WebPageTest を使用する分析
- Google Search Console で Core Web Vitals を監視する
- パフォーマンス バジェットとアラートを設定する
- 定期的なパフォーマンス監査を実施する
- パフォーマンス改善のための A/B テストを実施する
- Chrome DevTools のパフォーマンス パネルを使用してプロファイリングを行う

## 高度なテクニック

- リソースヒント（事前接続、事前ロード、事前フェッチ）を実装する
- 遅延読み込みには Intersection Observer を使用する
- サーバーサイドレンダリングまたは静的サイト生成を検討する
- stale-while-revalidate パターンを実装する
- 重要でないタスクには requestIdleCallback を使用する
- モジュールの読み込みには import map を検討する
- ユーザーの行動に基づいた予測プリフェッチを実装する
- 重要なリソースには優先度ヒントを使用する