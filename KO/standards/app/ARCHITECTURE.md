# WhytCard의 글로벌 아키텍처

## 소개

이 문서는 오픈소스 웹 스크래핑 및 AI 학습 플랫폼인 WhytCard 프로젝트의 글로벌 아키텍처를 설명합니다. 이 아키텍처는 모듈화되고 확장 가능하며 유지 관리가 용이하도록 설계되어 시스템 안정성을 보장하면서 새로운 기능을 쉽게 추가할 수 있습니다.

## 개요

WhytCard는 프런트엔드와 백엔드가 명확하게 분리된 클라이언트-서버 아키텍처로 구성되어 있습니다. 이러한 분리는 두 구성 요소의 독립적인 발전을 가능하게 하고 팀워크를 촉진합니다.

``` 
┌─────────────────┐ ┌─────────────────┐ 
│ │ │ │ 
│ 프런트엔드 │◄────►│ 백엔드 │ 
│ (Vue.js) │ │ (FastAPI) │ 
│ │ │ │ 
└──────────────────┘ └─────────────────┘ 
▲ 
│ 
▼ 
┌─────────────────┐ 
│ │ 
│ 스크래핑 및 │ 
│ 데이터 파이프라인 │ 
│ │ 
└────────────────┘ 
▲ 
│ 
▼ 
┌────────────────┐ 
│ │ 
│ 저장소 │ 
│ │ 
└────────────────┘ 
``` 

## 주요 구성 요소

### 1. 프런트엔드(Vue.js)

프런트엔드는 Vue.js로 개발되었으며, 스타일링에는 Tailwind CSS를 사용합니다. 사용자 인터페이스와 사용자 경험을 담당합니다.

#### 주요 기능

- **프레임워크**: Composition API를 지원하는 Vue.js 3
- **스타일링**: Tailwind CSS
- **애니메이션**: Framer Motion
- **국제화**: 브라우저 언어 자동 감지 기능을 갖춘 i18next
- **라우팅**: Vue Router
- **상태 관리**: Pinia

#### 구조

``` 
src/ 
├── components/ # 재사용 가능한 컴포넌트
├── config/ # 프런트엔드 구성
├── i18n/ # 번역 파일
├── router/ # 경로 구성
├── views/ # 메인 페이지
└── main.js # 진입점
``` 

### 2. 백엔드(FastAPI)

백엔드는 API 생성을 위한 최신 고성능 Python 프레임워크인 FastAPI를 사용하여 개발되었습니다. 모든 서버 작업, 데이터 액세스 및 비즈니스 로직을 처리합니다.

#### 주요 기능

- **프레임워크**: FastAPI
- **인증**: JWT
- **유효성 검사**: Pydantic
- **API 문서**: 통합 Swagger UI

#### 구조

``` 
backend/ 
├── config/ # 백엔드 구성
├── core/ # 주요 비즈니스 로직
│ ├── api/ # API 엔드포인트
│ ├── schemas/ # Pydantic 스키마
├── models/ # 데이터 모델
├── utils/ # 유틸리티
└── main.py # 진입점
``` 

### 3. 스크래핑 및 데이터 파이프라인

이 모듈은 웹 소스에서 데이터를 수집하고 AI 모델 학습을 위해 변환하는 역할을 합니다.

#### 주요 기능

- **스크래핑**: aiohttp 및 BeautifulSoup을 사용한 비동기 시스템
- **오케스트레이션**: 작업 및 우선순위 관리
- **변환**: 데이터 정리 및 정규화
- **캐시**: 중복 요청을 방지하기 위한 캐싱 시스템

#### 구조

``` 
백엔드/ 
├── 스크래핑/ 
│ ├── 스크래퍼/ # 다양한 소스에 대한 특정 구현
│ ├── utils/ # 스크래핑 유틸리티
│ ├── orchestrator.py # 작업 오케스트레이터
│ └── cache.py # 캐싱 시스템
└── datasets/ # 수집 및 변환된 데이터
``` 

### 4. 스토리지

스토리지 시스템은 데이터 지속성과 액세스를 관리합니다.

#### 저장 옵션

- **데이터베이스**: 구조화된 데이터용 PostgreSQL
- **파일 저장소**: 대용량 데이터용 로컬 파일 시스템 또는 S3 호환
- **캐시**: 분산 캐시용 Redis

## 데이터 흐름

### 1. 데이터 수집

``` 
┌──────────────┐ ┌─────────────┐ ┌─────────────┐ 
│ │ │ │ │ │ │ │ 
│ 웹 │────►│ 스크래퍼 │────►│ 캐시 │ 
│ 소스 │ │ │ │ │ 
└─────────────┘ └─────────────┘ └─────────────┘ 
│ 
▼ 
┌─────────────┐ ┌────────────┐ 
│ │ │ │ 
│ 프로세서 │────►│ 스토리지 │ 
│ │ │ │ 
└─────────────┘ └────────────┘ 
``` 

1. 스크래퍼는 웹 소스에서 데이터를 수집합니다.
2. 중복 요청을 방지하기 위해 데이터를 캐시합니다.
3. 프로세서는 데이터를 정리하고 변환합니다.
4. 변환된 데이터는 나중에 사용할 수 있도록 저장합니다.

### 2. 모델 학습

``` 
┌──────────────┐ ┌──────────────┐ ┌──────────────┐ 
│ │ │ │ │ │ │ 
│ 데이터셋 │────►│ 전처리기│────►│ 학습 │ 
│ │ │ │ │ │ 
└─────────────┘ └─────────────┘ └─────────────┘ 
│ 
▼ 
┌──────────────┐ 
│ │ 
│ 모델 │ 
│ │ 
└─────────────┘ 
``` 

1. 데이터셋은 다음에서 추출됩니다. 저장
2. 학습을 위해 데이터가 전처리됩니다.
3. 모델은 전처리된 데이터로 학습됩니다.
4. 학습된 모델은 저장됩니다.

### 3. 모델 사용

``` 
┌──────────────┐ ┌─────────────┐ ┌─────────────┐ 
│ │ │ │ │ │ │ 
│ API │────►│ 모델 │────►│ 응답 │ 
│ 요청 │ │ │ │ │ 
└─────────────┘ └─────────────┘ └─────────────┘ 
``` 

1. API 요청이 수신되었습니다.
2. 적절한 모델을 사용하여 요청을 처리합니다.
3. 응답이 생성되고 반환됩니다.

## 구성 요소 간 통신

### REST API

프런트엔드와 백엔드 간의 통신은 주로 REST API를 통해 이루어집니다. 엔드포인트는 Swagger UI를 통해 논리적으로 구성되고 문서화됩니다.

### 웹소켓

실시간 업데이트가 필요한 기능(예: 스크래핑 작업 추적)의 경우, 웹소켓을 사용하여 양방향 통신을 지원합니다.

### 메시지 큐

비동기적이고 장기 실행 작업의 경우, RabbitMQ 또는 Redis Pub/Sub와 같은 메시지 큐를 사용하여 구성 요소를 분리하고 안정성을 보장합니다.

## 배포

### 배포 옵션

WhytCard는 여러 가지 방법으로 배포할 수 있습니다.

1. **데스크톱 애플리케이션**: Tauri를 사용하여 크로스 플랫폼 데스크톱 애플리케이션 생성
2. **클라우드 배포**: AWS, GCP 또는 Azure와 같은 클라우드 서비스에 배포
3. **셀프 호스팅**: 개인 또는 회사 서버에 설치

### 배포 아키텍처

``` 
┌──────────────────┐ ┌─────────────────┐ 
│ │ │ │ 
│ 프런트엔드 │◄────►│ API 게이트웨이 │ 
│ (정적) │ │ │ 
└─────────────────┘ └────────────────┘ 
▲ 
│ 
▼ 
┌─────────────────┐ 
│ │ 
│ 백엔드 API │ 
│ │ 
└────────────────┘ 
▲ 
│ 
▼ 
┌──────────────────┐ ┌─────────────────┐ 
│ │ │ │ 
│ 데이터베이스 │ │ 파일 저장소 │ 
│ │ │ │ 
└───────────────────┘ └─────────────────┘ 
``` 

## 보안

### 보안 원칙

1. **심층 방어**: 다중 보안 계층
2. **최소 권한 원칙**: 필요한 최소한의 접근 권한
3. **입력 검증**: 모든 사용자 입력 검증
4. **데이터 보호**: 민감한 데이터 암호화

### 보안 조치

- **인증**: 토큰 순환을 통한 JWT
- **권한 부여**: 역할 기반 접근 제어
- **일반적인 공격으로부터 보호**: XSS, CSRF, SQL 인젝션
- **감사**: 중요 작업 로깅

## 확장성

아키텍처는 수평 및 수직 확장이 가능하도록 설계되었습니다.

- **마이크로서비스**: 구성 요소를 독립적으로 배포할 수 있습니다.
- **캐싱**: 다단계 캐시 사용
- **부하 분산**: 여러 인스턴스 간에 트래픽 분산
- **파티셔닝**: 성능 향상을 위한 데이터 분리

## 모니터링 및 관측 가능성

- **로깅**: ELK Stack 또는 이와 동등한 도구를 사용한 중앙 집중식 로깅
- **메트릭**: Prometheus를 사용한 메트릭 수집
- **추적**: OpenTelemetry를 사용한 요청 추적
- **알림**: 사전 정의된 임계값 기반 알림

## 결론

WhytCard의 아키텍처는 견고하고 확장 가능하며 유지 관리가 용이하도록 설계되었습니다. 각 구성 요소 간의 명확한 책임 분리는 독립적인 진화를 가능하게 하고 팀워크를 용이하게 합니다. 현재 및 미래의 프로젝트 요구 사항과 업계 모범 사례를 고려하여 기술을 선택했습니다.

이 아키텍처는 새로운 요구 사항과 기술 개발에 맞춰 정기적으로 검토 및 업데이트될 예정입니다.

--- 

최종 업데이트: 2025년 1월 15일