# Hướng dẫn chung về phong cách cho WhytCard ## Giới thiệu Tài liệu này định nghĩa phong cách mã hóa chung và các phương pháp hay nhất cần tuân theo trên tất cả các ngôn ngữ và công nghệ được sử dụng trong dự án WhytCard. Các tiêu chuẩn này đảm bảo tính nhất quán, khả năng bảo trì và chất lượng trong toàn bộ cơ sở mã. ## Mục lục 1. [Nguyên tắc cơ bản](#fundamental-principles) 2. [Quy ước đặt tên](#naming-conventions) 3. [Định dạng](#formatting) 4. [Tài liệu](#documentation) 5. [Cấu trúc mã](#code-structure) 6. [Nguyên tắc dành riêng cho ngôn ngữ](#language-specific-guidelines) 7. [Kiểm soát phiên bản](#version-control) ## Nguyên tắc cơ bản ### Rõ ràng hơn sự thông minh Luôn ưu tiên sự rõ ràng của mã hơn các giải pháp thông minh hoặc phức tạp: - Viết mã dễ hiểu - Tránh các tính năng ngôn ngữ khó hiểu trừ khi cần thiết - Ưu tiên khả năng đọc và khả năng bảo trì hơn sự ngắn gọn ### Tính nhất quán Duy trì tính nhất quán trong toàn bộ cơ sở mã: - Tuân theo các mẫu đã thiết lập trong dự án - Không trộn lẫn các phong cách hoặc cách tiếp cận khác nhau - Khi sửa đổi mã hiện có, hãy khớp với phong cách của nó ### DRY (Không lặp lại chính mình) Tránh trùng lặp mã: - Trích xuất mã lặp lại thành các hàm hoặc lớp - Tạo tiện ích dùng chung cho các hoạt động chung - Sử dụng kế thừa hoặc hợp thành để chia sẻ hành vi ### KISS (Giữ đơn giản, đồ ngốc) Ưu tiên các giải pháp đơn giản hơn các giải pháp phức tạp: - Bắt đầu với cách tiếp cận đơn giản nhất có hiệu quả - Chỉ thêm độ phức tạp khi cần thiết - Chia các vấn đề phức tạp thành các phần đơn giản hơn ### YAGNI (Bạn sẽ không cần nó) Không thêm chức năng cho đến khi cần thiết: - Tránh các tính năng suy đoán - Chỉ triển khai những gì cần thiết ngay bây giờ - Cấu trúc lại khi cần, không phải là trước ## Quy ước đặt tên ### Quy tắc chung - Tên phải mang tính mô tả và truyền đạt mục đích - Sử dụng các từ đầy đủ thay vì viết tắt (trừ những từ viết tắt thông dụng) - Nhất quán với các mẫu đặt tên hiện có ### Kiểu chữ hoa Sử dụng kiểu chữ hoa phù hợp cho từng ngôn ngữ: - **camelCase**: Biến và hàm JavaScript/TypeScript - **PascalCase**: Các lớp trong hầu hết các ngôn ngữ, các thành phần React - **snake_case**: Biến và hàm Python - **kebab-case**: Các phần tử HTML, lớp CSS, tên tệp - **UPPER_SNAKE_CASE**: Hằng số trong hầu hết các ngôn ngữ ### Đặt tên Ví dụ ```javascript // JavaScript const userProfile = { firstName: &#39;John&#39;, lastName: &#39;Doe&#39;, EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculateTotalPrice(items) { // Implementation } class UserManager { // Implementation } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculate_total_price(items): # Implementation pass class UserManager: # Implementation pass ``` ## Định dạng ### Thụt lề - Sử dụng thụt lề nhất quán trong toàn bộ dự án - Đối với JavaScript/TypeScript/HTML/CSS: 2 khoảng trắng - Đối với Python: 4 khoảng trắng (PEP 8) - Không bao giờ trộn lẫn tab và khoảng trắng ### Độ dài dòng - Giới hạn các dòng tối đa 100 ký tự đối với hầu hết các ngôn ngữ - Đối với Python, hãy làm theo PEP 8 (79 ký tự cho mã, 72 ký tự cho bình luận) - Ngắt các dòng dài theo cách tự nhiên đối với ngôn ngữ ### Khoảng cách - Sử dụng khoảng trắng xung quanh toán tử - Sử dụng khoảng trắng sau dấu phẩy và dấu chấm phẩy - Sử dụng khoảng cách nhất quán trong các lệnh gọi hàm và khai báo ### Dấu ngoặc vuông và khối - Dấu ngoặc vuông mở trên cùng một dòng đối với hầu hết các ngôn ngữ (trừ các hàm và lớp Python) - Sử dụng dấu ngoặc vuông nhất quán ngay cả đối với các khối một dòng - Căn chỉnh dấu ngoặc vuông đóng với đầu dòng mở ### Ví dụ ```javascript // Hàm JavaScript calculateDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculate_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Item 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Item 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Item 3&quot;, &quot;price&quot;: 30}, ] ``` ## Tài liệu ### Bình luận về mã - Sử dụng bình luận để giải thích &quot;tại sao&quot;, không phải &quot;cái gì&quot; - Bình luận về các thuật toán phức tạp hoặc các giải pháp không hiển nhiên - Cập nhật bình luận về các thay đổi của mã - Tránh các bình luận thừa hoặc hiển nhiên ### Tài liệu về hàm và phương pháp Ghi lại tất cả các hàm và phương pháp với: - Mô tả mục đích - Các tham số và kiểu của chúng - Giá trị trả về và kiểu - Các ngoại lệ có thể xảy ra - Ví dụ sử dụng cho các hàm phức tạp ### Tiêu đề tệp Bao gồm ở đầu mỗi tệp: - Mô tả ngắn gọn về mục đích của tệp - Tác giả thông tin - Ngày tạo - Thông tin giấy phép ### Ví dụ ```javascript /** * Tính tổng giá của các mặt hàng sau khi áp dụng chiết khấu. * * @param {Mảng<Object> } items - Mảng các đối tượng mục có thuộc tính giá * @param {number} discountPercent - Phần trăm giảm giá (0-100) * @returns {number} Tổng giá sau khi giảm giá * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculateTotalPrice(items, 10); // Trả về 27 */ function calculateTotalPrice(items, discountPercent) { // Triển khai } ``` ```python def calculate_total_price(items, discount_percent): &quot;&quot;&quot; Tính tổng giá của các mặt hàng sau khi áp dụng chiết khấu. Đối số: items: Danh sách các từ điển có thuộc tính giá discount_percent: Tỷ lệ phần trăm chiết khấu (0-100) Trả về: float: Tổng giá sau khi giảm giá Ví dụ: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculate_total_price(items, 10) # Trả về 27 &quot;&quot;&quot; # Triển khai ``` ## Cấu trúc mã ### Tổ chức tệp - Một lớp/thành phần chính cho mỗi tệp - Nhóm các chức năng liên quan trong cùng một thư mục - Tách giao diện khỏi triển khai khi cần thiết - Giữ các tệp có kích thước hợp lý (&lt; 500 dòng làm hướng dẫn) ### Kích thước hàm và phương thức - Giữ các hàm và phương thức nhỏ và tập trung - Hướng đến các hàm thực hiện tốt một việc - Giới hạn độ dài hàm (&lt; 50 dòng như một hướng dẫn) - Trích xuất logic phức tạp thành các hàm trợ giúp ### Quản lý phụ thuộc - Giảm thiểu sự phụ thuộc giữa các mô-đun - Sử dụng tiêm phụ thuộc để giảm sự liên kết - Ghi lại rõ ràng các phụ thuộc của mô-đun - Tránh các phụ thuộc tuần hoàn ### Xử lý lỗi - Xử lý lỗi ở cấp độ thích hợp - Sử dụng ngoại lệ cho các điều kiện đặc biệt - Cung cấp thông báo lỗi có ý nghĩa - Không nuốt ngoại lệ mà không có lý do chính đáng ## Hướng dẫn dành riêng cho ngôn ngữ ### JavaScript/TypeScript - Làm theo Hướng dẫn về phong cách JavaScript của Airbnb - Sử dụng các tính năng ES6+ khi thích hợp - Sử dụng TypeScript để đảm bảo an toàn kiểu - Ưu tiên các mẫu lập trình chức năng ```javascript // Ưu tiên const hơn let khi biến không được gán lại const PI = 3.14159; // Sử dụng các ký tự mẫu để nội suy chuỗi const greeting = `Hello, ${name}!`; // Sử dụng phép gán hủy cấu trúc const { firstName, lastName } = user; // Sử dụng các hàm mũi tên cho các lệnh gọi lại ngắn const double = numbers.map(n =&gt; n * 2); ``` ### Python - Thực hiện theo hướng dẫn về phong cách PEP 8 - Sử dụng gợi ý về kiểu (PEP 484) - Ưu tiên các dạng hiểu danh sách/dict cho các trường hợp đơn giản - Sử dụng trình quản lý ngữ cảnh để quản lý tài nguyên ```python # Sử dụng các dạng hiểu danh sách cho các phép biến đổi đơn giản double = [n * 2 cho n theo số] # Sử dụng trình quản lý ngữ cảnh để quản lý tài nguyên với open(&quot;file.txt&quot;, &quot;r&quot;) là f: content = f.read() # Sử dụng gợi ý về kiểu def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; ``` ### HTML/CSS - Sử dụng các phần tử HTML ngữ nghĩa - Thực hiện theo phương pháp BEM cho các lớp CSS - Giảm thiểu các kiểu nội tuyến - Sử dụng các biến CSS để tạo chủ đề ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title"> Tiêu đề</h2></header><div class="card__content"><p> Nội dung ở đây</p></div></article> ``` ```css /* Sử dụng biến CSS để tạo chủ đề */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* Thực hiện theo phương pháp BEM */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## Kiểm soát phiên bản ### Tin nhắn cam kết - Viết tin nhắn cam kết rõ ràng, có mô tả - Sử dụng cách diễn đạt bắt buộc (&quot;Thêm tính năng&quot; chứ không phải &quot;Tính năng đã thêm&quot;) - Tham chiếu số sự cố khi có thể - Tuân theo định dạng cam kết thông thường ``` có: thêm hệ thống xác thực người dùng - Triển khai xác thực dựa trên JWT - Thêm điểm cuối đăng nhập và đăng ký - Tạo phần mềm trung gian xác thực Đóng #123 ``` ### Chiến lược phân nhánh - Sử dụng các nhánh tính năng cho quá trình phát triển mới - Giữ cho nhánh chính/nhánh chính ổn định - Sử dụng các yêu cầu kéo để đánh giá mã - Xóa các nhánh sau khi hợp nhất ### Đánh giá mã - Đánh giá tất cả mã trước khi hợp nhất - Tập trung vào kiến trúc, bảo mật và hiệu suất - Có tính xây dựng và tôn trọng trong các bình luận - Sử dụng các công cụ tự động để phát hiện các sự cố về phong cách ## Kết luận Hướng dẫn về phong cách này được thiết kế để đảm bảo tính nhất quán và chất lượng trên toàn bộ cơ sở mã WhytCard. Mặc dù hướng dẫn này đề cập đến các nguyên tắc chung, hãy tham khảo các hướng dẫn dành riêng cho từng ngôn ngữ để biết các quy tắc chi tiết hơn. Hãy nhớ rằng mục tiêu là tạo ra mã dễ bảo trì, dễ đọc và mạnh mẽ. Tất cả các thành viên trong nhóm được mong đợi tuân theo các hướng dẫn này và giúp thực thi chúng thông qua các đánh giá mã và cố vấn. --- Cập nhật lần cuối: 2025-01-15 