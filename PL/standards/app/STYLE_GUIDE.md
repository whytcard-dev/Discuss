# Ogólny przewodnik po stylu dla WhytCard ## Wprowadzenie Niniejszy dokument definiuje ogólny styl kodowania i najlepsze praktyki, których należy przestrzegać we wszystkich językach i technologiach używanych w projekcie WhytCard. Te standardy zapewniają spójność, łatwość utrzymania i jakość w całej bazie kodu. ## Spis treści 1. [Podstawowe zasady](#fundamental-principles) 2. [Konwencje nazewnictwa](#naming-conventions) 3. [Formatowanie](#formatting) 4. [Dokumentacja](#documentation) 5. [Struktura kodu](#code-structure) 6. [Wytyczne specyficzne dla języka](#language-specific-guidelines) 7. [Kontrola wersji](#version-control) ## Podstawowe zasady ### Przejrzystość ponad pomysłowość Zawsze stawiaj przejrzystość kodu ponad pomysłowość lub złożoność rozwiązań: - Twórz kod łatwy do zrozumienia - Unikaj niejasnych funkcji języka, chyba że jest to konieczne - Stawiaj czytelność i łatwość utrzymania ponad zwięzłość ### Spójność Zachowaj spójność w całej bazie kodu: - Stosuj ustalone wzorce w projekcie - Nie mieszaj różnych stylów lub podejść - Podczas modyfikowania istniejącego kodu dopasuj jego styl ### DRY (Don&#39;t Repeat Yourself) Unikaj duplikacji kodu: - Wyodrębnij powtórzony kod do funkcji lub klas - Twórz współdzielone narzędzia do typowych operacji - Używaj dziedziczenia lub kompozycji, aby współdzielić zachowanie ### KISS (Keep It Simple, Stupid) Preferuj proste rozwiązania od skomplikowanych: - Zacznij od najprostszego podejścia, które działa - Dodawaj złożoność tylko wtedy, gdy jest to konieczne - Podziel złożone problemy na prostsze części ### YAGNI (You Aren&#39;t Gonna Need It) Nie dodawaj funkcjonalności, dopóki nie będzie to konieczne: - Unikaj spekulatywnych funkcji - Implementuj tylko to, co jest wymagane teraz - Refaktoryzuj, gdy jest to potrzebne, a nie prewencyjnie ## Konwencje nazewnictwa ### Zasady ogólne - Nazwy powinny być opisowe i przekazywać cel - Używaj pełnych słów, a nie skrótów (poza tymi powszechnie używanymi) - Bądź spójny z istniejącymi wzorcami nazewnictwa ### Style przypadków Używaj odpowiedniego stylu przypadków dla każdego języka: - **camelCase**: zmienne i funkcje JavaScript/TypeScript - **PascalCase**: klasy w większości języków, komponenty React - **snake_case**: Python zmienne i funkcje - **kebab-case**: elementy HTML, klasy CSS, nazwy plików - **UPPER_SNAKE_CASE**: stałe w większości języków ### Przykłady nazewnictwa ```javascript // JavaScript const userProfile = { firstName: &#39;John&#39;, lastName: &#39;Doe&#39;, EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculatedTotalPrice(items) { // Implementacja } class UserManager { // Implementacja } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculator_total_price(items): # Przejście implementacji class UserManager: # Przejście implementacji ``` ## Formatowanie ### Wcięcie — używaj spójnego wcięcia w całym projekcie — dla JavaScript/TypeScript/HTML/CSS: 2 spacje — dla Pythona: 4 spacje (PEP 8) — nigdy nie mieszaj tabulatorów i spacji ### Długość linii — ogranicz linie do maksymalnie 100 znaków dla większości języków — dla Pythona postępuj zgodnie z PEP 8 (79 znaków dla kodu, 72 dla komentarzy) — dziel długie linie w sposób naturalny dla danego języka ### Odstępy — używaj spacji wokół operatorów — używaj spacji po przecinkach i średnikach — stosuj spójne odstępy w wywołaniach funkcji i deklaracjach ### Nawiasy i bloki — otwieranie nawiasów w tym samym wierszu w przypadku większości języków (z wyjątkiem funkcji i klas Pythona) — spójne stosowanie nawiasów nawet w przypadku bloków jednowierszowych — wyrównywanie zamykających nawiasów z początkiem wiersza otwierającego ### Przykłady ```javascript // JavaScript function calculatorDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculator_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Item 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Item 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Item 3&quot;, &quot;price&quot;: 30}, ] ``` ## Dokumentacja ### Komentarze do kodu - Użyj komentarzy, aby wyjaśnić „dlaczego”, a nie „co” - Komentuj złożone algorytmy lub nieoczywiste rozwiązania - Aktualizuj komentarze o zmianach w kodzie - Unikaj powtarzających się lub oczywistych komentarzy ### Dokumentacja funkcji i metod Dokumentuj wszystkie funkcje i metody, podając: - Opis celu - Parametry i ich typy - Wartość zwracaną i typ - Wyjątki, które mogą zostać zgłoszone - Przykłady użycia złożonych funkcji ### Nagłówki plików Umieść na początku każdego pliku: - Krótki opis cel pliku - Informacje o autorze(ach) - Data utworzenia - Informacje o licencji ### Przykłady ```javascript /** * Oblicza całkowitą cenę przedmiotów po zastosowaniu rabatów. * * @param {Array<Object> } items - Tablica obiektów przedmiotów z właściwością ceny * @param {number} discountPercent - Procent rabatu (0-100) * @returns {number} Cena całkowita po rabacie * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculatorTotalPrice(items, 10); // Zwraca 27 */ function calculatedTotalPrice(items, discountPercent) { // Implementacja } ``` ```python def calculator_total_price(items, discount_percent): &quot;&quot;&quot; Oblicz całkowitą cenę przedmiotów po zastosowaniu rabatów. Argumenty: items: Lista słowników z właściwością price discount_percent: Procent rabatu (0-100) Zwraca: float: Całkowita cena po rabacie Przykład: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculator_total_price(items, 10) # Zwraca 27 &quot;&quot;&quot; # Implementacja ``` ## Struktura kodu ### Organizacja plików - Jedna podstawowa klasa/komponent na plik - Grupuj powiązane funkcjonalności w tym samym katalogu - Oddziel interfejs od implementacji, gdy jest to właściwe - Utrzymuj pliki o rozsądnym rozmiarze (&lt; 500 wierszy jako wytyczne) ### Rozmiar funkcji i metod - Utrzymuj funkcje i metody małe i skoncentrowane - Dąż do funkcje, które dobrze wykonują jedną czynność — Ogranicz długość funkcji (wytyczne: &lt; 50 wierszy) — Wyodrębnij złożoną logikę do funkcji pomocniczych ### Zarządzanie zależnościami — Minimalizuj zależności między modułami — Używaj wstrzykiwania zależności w celu zmniejszenia sprzężeń — Jasno dokumentuj zależności modułów — Unikaj zależności cyklicznych ### Obsługa błędów — Obsługuj błędy na odpowiednim poziomie — Używaj wyjątków w wyjątkowych sytuacjach — Dostarczaj zrozumiałe komunikaty o błędach — Nie połykaj wyjątków bez powodu ## Wytyczne dotyczące konkretnych języków ### JavaScript/TypeScript — Postępuj zgodnie z przewodnikiem po stylu JavaScript w Airbnb — Używaj funkcji ES6+, gdy jest to odpowiednie — Używaj TypeScript ze względu na bezpieczeństwo typu — Preferuj wzorce programowania funkcyjnego ```javascript // Preferuj const nad let, gdy zmienna nie zostanie ponownie przypisana const PI = 3.14159; // Używaj literałów szablonów do interpolacji ciągu znaków const Greeting = `Witaj, ${name}!`; // Używaj przypisania destrukturyzacyjnego const { firstName, lastName } = user; // Użyj funkcji strzałkowych do krótkich wywołań zwrotnych const doubled = numbers.map(n =&gt; n * 2); ``` ### Python - Postępuj zgodnie ze stylem PEP 8 - Używaj wskazówek dotyczących typów (PEP 484) - Preferuj wyrażenia list/słowników w prostych przypadkach - Używaj menedżerów kontekstu do zarządzania zasobami ```python # Używaj wyrażeń list do prostych transformacji doubled = [n * 2 for n in numbers] # Używaj menedżerów kontekstu do zarządzania zasobami z open(&quot;file.txt&quot;, &quot;r&quot;) as f: content = f.read() # Używaj wskazówek dotyczących typów def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; ``` ### HTML/CSS - Używaj semantycznych elementów HTML - Postępuj zgodnie z metodologią BEM dla klas CSS - Minimalizuj style wbudowane - Używaj zmiennych CSS do motywów ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title"> Tytuł</h2></header><div class="card__content"><p> Treść tutaj</p></div></article> ``` ```css /* Użyj zmiennych CSS do motywu */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* Postępuj zgodnie z metodologią BEM */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## Kontrola wersji ### Komunikaty zatwierdzenia — pisz jasne, opisowe komunikaty zatwierdzenia — używaj trybu rozkazującego („Dodaj funkcję”, a nie „Dodano funkcję”) — odwołuj się do numerów problemów, gdy jest to możliwe — stosuj konwencjonalny format zatwierdzeń ``` cecha: dodaj system uwierzytelniania użytkowników — implementuj uwierzytelnianie oparte na JWT — dodaj punkty końcowe logowania i rejestracji — twórz oprogramowanie pośredniczące uwierzytelniania Zamyka #123 ``` ### Strategia rozgałęzienia — używaj gałęzi funkcji do nowych opracowań — utrzymuj stabilność gałęzi głównej/głównej — używaj żądań ściągnięcia do przeglądu kodu — usuwaj gałęzie po scaleniu ### Przeglądy kodu — przejrzyj cały kod przed scaleniem — skup się na architekturze, bezpieczeństwie i wydajności — bądź konstruktywny i pełen szacunku w komentarzach — używaj zautomatyzowanych narzędzi do wychwytywania problemów ze stylem ## Wnioski Niniejszy przewodnik po stylach ma na celu zapewnienie spójności i jakości w całej bazie kodu WhytCard. Chociaż obejmuje on ogólne zasady, zapoznaj się z przewodnikami dotyczącymi poszczególnych języków, aby uzyskać bardziej szczegółowe zasady. Pamiętaj, że celem jest tworzenie łatwego w utrzymaniu, czytelnego i solidnego kodu. Oczekuje się, że wszyscy członkowie zespołu będą przestrzegać tych wytycznych i pomagać w ich egzekwowaniu poprzez przeglądy kodu i mentoring. --- Ostatnia aktualizacja: 2025-01-15 