# มาตรฐานคุณภาพโค้ด 

## หลักการสำคัญ 

- เขียนโค้ดที่สะอาด บำรุงรักษาได้ และจัดทำเอกสารด้วยตัวเอง 
- ปฏิบัติตามหลักการ SOLID และ DRY 
- ให้ฟังก์ชันมีขนาดเล็กและเน้นที่เป้าหมาย (ความรับผิดชอบเดียว) 
- ใช้การตั้งชื่อที่อธิบายได้สำหรับตัวแปร ฟังก์ชัน และคลาส 
- รักษารูปแบบโค้ดที่สอดคล้องกันทั่วทั้งโครงการ 
- จัดทำเอกสารตรรกะที่ซับซ้อนและ API สาธารณะ 
- เขียนโค้ดสำหรับมนุษย์ ไม่ใช่แค่เครื่องจักร 

## มาตรฐาน JavaScript/TypeScript 

### การกำหนดค่า TypeScript 

- ใช้โหมดเข้มงวด (`"strict": true`) 
- เปิดใช้งานตัวเลือกการตรวจสอบประเภทที่แนะนำทั้งหมด 
- กำหนดค่าความละเอียดของโมดูลที่เหมาะสม 
- ตั้งค่าเวอร์ชัน ECMAScript เป้าหมายที่เหมาะสม 
- ระบุรูปแบบรวม/ไม่รวม 
- ใช้ชื่อแทนเส้นทางสำหรับการนำเข้าที่สะอาดกว่า 

### ข้อตกลงการตั้งชื่อ 

- **ตัวแปร/ฟังก์ชัน**: camelCase (`getUserData`, `calculateTotal`) 
- **คลาส/อินเทอร์เฟซ/ประเภท**: PascalCase (`UserProfile`, `ApiResponse`) 
- **ค่าคงที่**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`, `API_URL`) 
- **คุณสมบัติส่วนตัว**: ใช้คำนำหน้า `#` หรือข้อตกลง `_` (`#privateField`, `_privateMethod`) 
- **ตัวแปรบูลีน**: ใช้คำนำหน้า "is", "has", "can" (`isActive`, `hasPermission`) 
- **ไฟล์ส่วนประกอบ**: PascalCase ที่มีนามสกุล (`UserCard.tsx`) 
- **ไฟล์ยูทิลิตี้**: camelCase ที่มีนามสกุล (`formatDate.ts`) 

### การจัดระเบียบโค้ด 

- คลาส/ส่วนประกอบหนึ่งรายการต่อไฟล์ 
- จัดกลุ่มการนำเข้าตามภายนอก/ภายใน 
- เรียงลำดับการนำเข้าตามตัวอักษร 
- ใช้ไฟล์ส่งออกบาร์เรล (`index.ts`) สำหรับฟังก์ชันที่เกี่ยวข้อง 
- จัดระเบียบโค้ดตามฟีเจอร์/โมดูล 
- เก็บไฟล์ให้ไม่เกิน 400 บรรทัด (แยกหากมากกว่านั้น) 
- เก็บฟังก์ชันให้ไม่เกิน 50 บรรทัด 
- การซ้อนไฟล์สูงสุด: ลึก 3-4 ระดับ 

### แนวทางปฏิบัติที่ดีที่สุด 

- เลือกความไม่เปลี่ยนแปลง (const, readonly, Object.freeze) 
- ใช้การเชื่อมโยงและการรวมไฟล์แบบ null ที่เป็นทางเลือก 
- ใช้การจัดการข้อผิดพลาดที่เหมาะสม 
- หลีกเลี่ยงประเภทใดๆ ยกเว้นเมื่อจำเป็น 
- ใช้การป้องกันประเภทสำหรับการตรวจสอบประเภทระหว่างรันไทม์ 
- เลือกแบบ async/await มากกว่าคำสัญญาแบบดิบ 
- หลีกเลี่ยงตัวเลขและสตริงวิเศษ (ใช้ค่าคงที่) 
- ใช้การตรวจสอบ null/undefined ที่เหมาะสม 
- ใช้การส่งคืนล่วงหน้าเพื่อลดการซ้อนไฟล์ 

## มาตรฐาน React 

### โครงสร้างส่วนประกอบ 

- เลือกส่วนประกอบที่ใช้งานได้โดยใช้ตัวเชื่อม 
- ใช้การส่งออกที่มีชื่อสำหรับส่วนประกอบ 
- ใช้การตรวจสอบพร็อพด้วย TypeScript 
- แยกตรรกะที่ซับซ้อนไปยังฮุกที่กำหนดเอง 
- ให้ส่วนประกอบต่างๆ มุ่งเน้นไปที่ข้อกังวลของ UI 
- ใช้ขอบเขตข้อผิดพลาดที่เหมาะสม 
- ใช้ React.memo สำหรับการเพิ่มประสิทธิภาพการทำงาน 
- แยกส่วนประกอบที่นำกลับมาใช้ใหม่ได้ 

### การจัดการสถานะ 

- ใช้สถานะภายในสำหรับข้อมูลเฉพาะส่วนประกอบ 
- ใช้บริบทสำหรับสถานะที่ใช้ร่วมกันระหว่างส่วนประกอบต่างๆ 
- พิจารณาการจัดการสถานะภายนอกสำหรับแอปที่ซับซ้อน 
- ทำให้สถานะเป็นมาตรฐานและน้อยที่สุด 
- ใช้การเริ่มต้นสถานะที่เหมาะสม 
- ใช้ตัวลดสำหรับตรรกะสถานะที่ซับซ้อน 
- หลีกเลี่ยงการเจาะข้อมูลพร็อพ (ใช้การจัดองค์ประกอบหรือบริบท) 

### การเพิ่มประสิทธิภาพการทำงาน 

- ใช้ React.memo สำหรับส่วนประกอบล้วนๆ 
- ใช้ useMemo สำหรับการคำนวณที่มีราคาแพง 
- ใช้ useCallback สำหรับการจดจำฟังก์ชัน 
- จำลองรายการยาว (react-window, react-virtualized) 
- ใช้แอเรย์การอ้างอิงที่เหมาะสมในฮุก 
- หลีกเลี่ยงการเรนเดอร์ซ้ำที่ไม่จำเป็น 
- ใช้ React Profiler เพื่อระบุคอขวด 

## การทดสอบ มาตรฐาน 

### การทดสอบยูนิต 

- ทดสอบตรรกะทางธุรกิจและยูทิลิตี้ทั้งหมด 
- ใช้ Jest หรือ Vitest เป็นตัวเรียกใช้การทดสอบ 
- ใช้งานการจำลองการอ้างอิงอย่างเหมาะสม 
- ใช้ไลบรารีการทดสอบสำหรับการทดสอบส่วนประกอบ 
- ปฏิบัติตามรูปแบบ AAA (จัดเรียง ดำเนินการ ยืนยัน) 
- เขียนชื่อการทดสอบที่อธิบายได้ 
- ตั้งเป้าให้ครอบคลุมโค้ดมากกว่า 80% 
- ทดสอบกรณีขอบและสถานการณ์ข้อผิดพลาด 

### การทดสอบการรวมระบบ 

- ทดสอบการโต้ตอบของส่วนประกอบ 
- ทดสอบการส่งแบบฟอร์มและโฟลว์ของผู้ใช้ 
- ใช้ MSW สำหรับการจำลอง API 
- ทดสอบการกำหนดเส้นทางและการนำทาง 
- ตรวจสอบการเปลี่ยนแปลงสถานะ 
- ทดสอบด้วยข้อมูลที่สมจริง 

### การทดสอบแบบครบวงจร 

- ใช้ Cypress หรือ Playwright 
- ทดสอบการเดินทางของผู้ใช้ที่สำคัญ 
- ทดสอบบนเบราว์เซอร์หลายตัว 
- ใช้งานการแยกการทดสอบอย่างเหมาะสม 
- ใช้แอตทริบิวต์ข้อมูลสำหรับตัวเลือกการทดสอบ 
- ใช้งานตรรกะการลองซ้ำสำหรับการทดสอบที่ไม่แน่นอน 
- ทดสอบ การเข้าถึงได้ 

## มาตรฐานการตรวจสอบโค้ด 

### กระบวนการ 

- ต้องตรวจสอบโค้ดทั้งหมดก่อนทำการรวม 
- การตรวจสอบอัตโนมัติต้องผ่านก่อนการตรวจสอบ 
- ใช้เทมเพลตคำขอแบบ pull request 
- ให้ PR มีขนาดเล็กและเน้นที่ 
- ตอบกลับความคิดเห็นในการตรวจสอบทันที 
- แก้ไขความคิดเห็นทั้งหมดก่อนทำการรวม 
- กำจัดการคอมมิตก่อนทำการรวม 

### รายการตรวจสอบการตรวจสอบ 

- โค้ดปฏิบัติตามมาตรฐานของโครงการ 
- รวมการทดสอบและผ่าน 
- อัปเดตเอกสาร 
- ไม่มีช่องโหว่ด้านความปลอดภัย 
- พิจารณาผลกระทบต่อประสิทธิภาพ 
- ตรงตามข้อกำหนดการเข้าถึง 
- จัดการกรณีขอบ 
- ไม่มีโค้ดหรือการอ้างอิงที่ไม่จำเป็น 

## เครื่องมือ 

### การลินต์และการจัดรูปแบบ 

- ESLint ที่มีกฎที่เหมาะสม 
- Prettier สำหรับการจัดรูปแบบที่สอดคล้องกัน 
- Husky สำหรับฮุกก่อนการคอมมิต 
- การจัดเตรียมลินต์สำหรับการลินต์แบบเพิ่ม 
- คอมไพเลอร์ TypeScript สำหรับประเภท การตรวจสอบ
- Stylelint สำหรับ CSS/SCSS

### การวิเคราะห์แบบสถิต

- SonarQube หรือ CodeClimate
- การตรวจสอบเมตริกความซับซ้อน
- การตรวจจับโค้ดซ้ำ
- การสแกนช่องโหว่ด้านความปลอดภัย
- การวิเคราะห์ขนาดกลุ่ม
- การตรวจจับโค้ดที่ไม่ได้ใช้

### การรวม CI/CD

- เรียกใช้การตรวจสอบทั้งหมดในทุก PR

- การรวมบล็อกหากการตรวจสอบล้มเหลว
- สร้างและเผยแพร่รายงานการครอบคลุมการทดสอบ
- นำการทดสอบการถดถอยประสิทธิภาพมาใช้
- อัปเดตการอ้างอิงโดยอัตโนมัติ
- ปรับใช้สภาพแวดล้อมการแสดงตัวอย่าง