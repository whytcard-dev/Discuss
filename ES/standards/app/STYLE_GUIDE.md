Guía de estilo general para WhytCard Introducción Este documento define el estilo general de codificación y las mejores prácticas a seguir en todos los lenguajes y tecnologías utilizados en el proyecto WhytCard. Estos estándares garantizan la consistencia, la facilidad de mantenimiento y la calidad en todo el código base. ## Tabla de contenido 1. [Principios fundamentales](#fundamental-principles) 2. [Convenciones de nomenclatura](#naming-conventions) 3. [Formato](#formatting) 4. [Documentación](#documentation) 5. [Estructura del código](#code-structure) 6. [Directrices específicas del lenguaje](#language-specific-guidelines) 7. [Control de versiones](#version-control) ## Principios fundamentales ### Claridad sobre inteligencia Priorice siempre la claridad del código sobre las soluciones inteligentes o complejas: - Escriba código que sea fácil de entender - Evite características oscuras del lenguaje a menos que sea necesario - Priorice la legibilidad y la facilidad de mantenimiento sobre la brevedad ### Consistencia Mantenga la consistencia en todo el código base: - Siga los patrones establecidos en el proyecto - No mezcle diferentes estilos o enfoques - Al modificar el código existente, coincida con su estilo ### DRY (Don&#39;t Repeat Yourself) Evite la duplicación de código: - Extraiga el código repetido en funciones o clases - Crea utilidades compartidas para operaciones comunes - Usa herencia o composición para compartir comportamiento ### KISS (Keep It Simple, Stupid) Prefiere soluciones simples a complejas: - Comienza con el enfoque más simple que funcione - Agrega complejidad solo cuando sea necesario - Divide los problemas complejos en partes más simples ### YAGNI (You Aren&#39;t Gonna Need It) No agregues funcionalidad hasta que sea necesario: - Evita características especulativas - Implementa solo lo que se requiere ahora - Refactoriza cuando sea necesario, no de manera preventiva ## Convenciones de nomenclatura ### Reglas generales - Los nombres deben ser descriptivos y transmitir un propósito - Usa palabras completas en lugar de abreviaturas (excepto las comunes) - Sé consistente con los patrones de nomenclatura existentes ### Estilos de mayúsculas y minúsculas Usa el estilo de mayúsculas y minúsculas apropiado para cada lenguaje: - **camelCase**: Variables y funciones de JavaScript/TypeScript - **PascalCase**: Clases en la mayoría de los lenguajes, componentes de React - **snake_case**: Variables y funciones de Python - **kebab-case**: Elementos HTML, clases CSS, nombres de archivos - **UPPER_SNAKE_CASE**: Constantes en la mayoría de los idiomas ### Ejemplos de nombres ```javascript // JavaScript const userProfile = { firstName: &#39;John&#39;, lastName: &#39;Doe&#39;, EMAIL_REGEX: /^[^@]+@[^@]+\.[^@]+$/, }; function calculateTotalPrice(items) { // Implementación } class UserManager { // Implementación } ``` ```python # Python user_profile = { &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Doe&quot;, &quot;EMAIL_REGEX&quot;: r&quot;^[^@]+@[^@]+\.[^@]+$&quot;, } def calculate_total_price(items): # Paso de implementación class UserManager: # Paso de implementación ``` ## Formato ### Sangría - Use una sangría consistente en todo el proyecto - Para JavaScript/TypeScript/HTML/CSS: 2 espacios - Para Python: 4 espacios (PEP 8) - Nunca mezcle tabulaciones y espacios ### Longitud de línea - Limite las líneas a un máximo de 100 caracteres para la mayoría de los lenguajes - Para Python, siga PEP 8 (79 caracteres para código, 72 para comentarios) - Divida las líneas largas de una manera que sea natural para el lenguaje ### Espaciado - Use espacios alrededor de los operadores - Utilice espacios después de comas y punto y coma - Utilice un espaciado consistente en las llamadas y declaraciones de funciones ### Corchetes y bloques - Corchetes de apertura en la misma línea para la mayoría de los idiomas (excepto para las funciones y clases de Python) - Uso consistente de corchetes incluso para bloques de una sola línea - Alinee los corchetes de cierre con el comienzo de la línea de apertura ### Ejemplos ```javascript // JavaScript function calculateDiscount(price, discountPercent) { if (price &lt;= 0) { return 0; } const discount = price * (discountPercent / 100); return discount; } const items = [ { name: &#39;Item 1&#39;, price: 10 }, { name: &#39;Item 2&#39;, price: 20 }, { name: &#39;Item 3&#39;, price: 30 }, ]; ``` ```python # Python def calculate_discount(price, discount_percent): if price &lt;= 0: return 0 discount = price * (discount_percent / 100) return discount items = [ {&quot;name&quot;: &quot;Artículo 1&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;Artículo 2&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;Artículo 3&quot;, &quot;price&quot;: 30}, ] ``` ## Documentación ### Comentarios de código - Use comentarios para explicar &quot;por qué&quot;, no &quot;qué&quot; - Comente algoritmos complejos o soluciones no obvias - Mantenga los comentarios actualizados con los cambios de código - Evite comentarios redundantes u obvios ### Documentación de funciones y métodos Documente todas las funciones y métodos con: - Descripción del propósito - Parámetros y sus tipos - Valor y tipo de retorno - Excepciones que se pueden lanzar - Ejemplos de uso para funciones complejas ### Encabezados de archivo Incluya al comienzo de cada archivo: - Breve descripción del propósito del archivo - Información del autor (es) - Fecha de creación - Información de licencia ### Ejemplos ```javascript /** * Calcula el precio total de los artículos después de aplicar descuentos. * * @param {Array<Object> } items - Matriz de objetos de artículo con propiedad de precio * @param {number} discountPercent - Porcentaje de descuento (0-100) * @returns {number} Precio total después del descuento * * @example * const items = [{ price: 10 }, { price: 20 }]; * const total = calculateTotalPrice(items, 10); // Devuelve 27 */ function calculateTotalPrice(items, discountPercent) { // Implementación } ``` ```python def calculate_total_price(items, discount_percent): &quot;&quot;&quot; Calcula el precio total de los artículos después de aplicar los descuentos. Args: items: Lista de diccionarios con la propiedad de precio discount_percent: Porcentaje de descuento (0-100) Devuelve: float: Precio total después del descuento Ejemplo: items = [{&quot;price&quot;: 10}, {&quot;price&quot;: 20}] total = calculate_total_price(items, 10) # Devuelve 27 &quot;&quot;&quot; # Implementación ``` ## Estructura del código ### Organización de archivos: una clase o componente principal por archivo; agrupa la funcionalidad relacionada en el mismo directorio; separa la interfaz de la implementación cuando sea apropiado; mantén los archivos de tamaño razonable (menos de 500 líneas como guía); ### Tamaño de funciones y métodos: mantén las funciones y los métodos pequeños y enfocados; busca funciones que hagan bien una cosa; limita la longitud de las funciones (menos de 50 líneas). como guía) - Extraer lógica compleja en funciones auxiliares ### Gestión de dependencias - Minimizar las dependencias entre módulos - Usar inyección de dependencias para reducir el acoplamiento - Documentar claramente las dependencias de los módulos - Evitar las dependencias circulares ### Manejo de errores - Manejar los errores en el nivel apropiado - Usar excepciones para condiciones excepcionales - Proporcionar mensajes de error significativos - No tragarse excepciones sin una buena razón ## Pautas específicas del lenguaje ### JavaScript/TypeScript - Seguir la Guía de estilo de JavaScript de Airbnb - Usar funciones de ES6+ cuando sea apropiado - Usar TypeScript para seguridad de tipos - Preferir patrones de programación funcional ```javascript // Preferir const sobre let cuando la variable no será reasignada const PI = 3.14159; // Usar literales de plantilla para interpolación de cadenas const greeting = `Hello, ${name}!`; // Usar asignación de desestructuración const { firstName, lastName } = user; // Usar funciones de flecha para devoluciones de llamadas cortas const doubled = numbers.map(n =&gt; n * 2); ``` ### Python - Seguir la guía de estilo PEP 8 - Usar sugerencias de tipo (PEP 484) - Preferir listas/dictados por comprensión para casos simples - Usar administradores de contexto para la administración de recursos ```python # Usar listas por comprensión para transformaciones simples doubled = [n * 2 para n en números] # Usar administradores de contexto para la administración de recursos with open(&quot;file.txt&quot;, &quot;r&quot;) as f: content = f.read() # Usar sugerencias de tipo def greet(name: str) -&gt; str: return f&quot;Hello, {name}!&quot; ``` ### HTML/CSS - Usar elementos HTML semánticos - Seguir la metodología BEM para clases CSS - Minimizar los estilos en línea - Usar variables CSS para temas ```html <!-- Use semantic HTML --><article class="card"><header class="card__header"><h2 class="card__title"> Título</h2></header><div class="card__content"><p> El contenido va aquí</p></div></article> ``` ```css /* Usar variables CSS para la temática */ :root { --primary-color: #3498db; --secondary-color: #2ecc71; } .card { border: 1px solid var(--primary-color); } /* Seguir la metodología BEM */ .card__header { background-color: var(--primary-color); } .card__title { font-size: 1.5rem; } ``` ## Control de versiones ### Mensajes de confirmación - Escribe mensajes de confirmación claros y descriptivos - Usa el modo imperativo (&quot;Agregar característica&quot; no &quot;Característica agregada&quot;) - Haz referencia a los números de problema cuando corresponda - Sigue el formato de confirmación convencional ``` hazaña: agregar sistema de autenticación de usuarios - Implementa autenticación basada en JWT - Agrega puntos finales de inicio de sesión y registro - Crea middleware de autenticación Cierra #123 ``` ### Estrategia de ramificación - Usa ramas de características para nuevo desarrollo - Mantén estable la rama principal/maestra - Usa solicitudes de extracción para revisión de código - Elimina ramas después de fusionar ### Revisiones de código - Revisa todo el código antes de fusionar - Enfócate en la arquitectura, seguridad y rendimiento - Sé constructivo y respetuoso en los comentarios - Usa herramientas automatizadas para detectar problemas de estilo ## Conclusión Esta guía de estilo está diseñada para garantizar la consistencia y calidad en todo el código base de WhytCard. Si bien cubre principios generales, consulta las guías específicas del lenguaje para obtener reglas más detalladas. Recuerda que el objetivo es crear código mantenible, legible y robusto. Se espera que todos los miembros del equipo sigan estas pautas y ayuden a aplicarlas a través de revisiones de código y tutoría. --- Última actualización: 15/01/2025 