# Webテスト標準

## テストの哲学

- 早期に、そして頻繁にテストする
- 可能な限りテストを自動化する
- 適切なレベル（単体テスト、統合テスト、E2Eテスト）でテストする
- 保守性と信頼性に優れたテストを書く
- 正常なパスとエッジケースの両方をテストする
- 回帰を防ぐためにテストを使用する
- ビジネスへの影響に基づいてテストの優先順位を付ける
- テストコードは本番コードと同様に慎重に扱う

## テストの種類とカバレッジ

### 単体テスト

- **対象**: 個々の関数、コンポーネント、モジュール
- **カバレッジ目標**: ビジネスロジックとユーティリティの80%以上
- **ツール**: Jest、Vitest、Reactテストライブラリ
- **ベストプラクティス**:
- AAAパターン（Arrange、Act、Assert）に従う
- 可能な場合はテストごとに1つのアサーションを使用する
- 外部依存関係をモック化する
- エッジケースとエラー条件をテストする
- テストを高速に保つ(テストあたり 100 ミリ秒未満)
- 説明的なテスト名を使用する
- テストを互いに分離する

### 統合テスト

- **ターゲット**: コンポーネントとサービス間のインタラクション
- **カバレッジ目標**: 重要なユーザーフローとコンポーネントインタラクション
- **ツール**: React Testing Library、MSW、Supertest
- **ベストプラクティス**:
- コンポーネント構成をテストする
- フォーム送信をテストする
- API レスポンスをモック化する
- 状態の変化をテストする
- DOM の更新を確認する
- ルーティングとナビゲーションをテストする
- 現実的なテストデータを使用する

### エンドツーエンドテスト

- **ターゲット**: UI からバックエンドまでの完全なユーザーフロー
- **カバレッジ目標**: 重要なビジネスパスとユーザージャーニー
- **ツール**: Cypress、Playwright
- **ベストプラクティス**:
- 重要なユーザージャーニーに焦点を当てる
- 複数のブラウザ
- 安定したセレクタ (data-testid) を使用する
- 分離されたテスト環境を構築する
- テストデータを効果的に管理する
- 失敗した場合にスクリーンショットを撮る
- 不安定なテストに対して再試行ロジックを実装する

### ビジュアル回帰テスト

- **ターゲット**: UI の外観とレイアウト
- **カバレッジ目標**: 主要な UI コンポーネントとページ
- **ツール**: Percy、Chromatic、Playwright
- **ベストプラクティス**:
- ベースラインのスクリーンショットをキャプチャする
- 異なるビューポートでテストする
- 動的なコンテンツを無視する
- ビジュアルの変更を注意深く確認する
- ライト/ダークモードをテストする
- 異なるコンテンツの長さでテストする
- CI/CD パイプラインと統合する

### アクセシビリティテスト

- **ターゲット**: WCAG コンプライアンスとアクセシビリティの問題
- **カバレッジ目標**: ユーザー向けのすべてのコンポーネントとページ
- **ツール**: axe、Lighthouse、WAVE
- **ベストプラクティス**:
- キーボードナビゲーションのテスト
- スクリーンリーダーの互換性の確認
- 色コントラストの確認
- フォーカス管理のテスト
- ARIA属性の検証
- 支援技術を使用したテスト
- 基本的なアクセシビリティチェックの自動化

### パフォーマンステスト

- **ターゲット**: ページの読み込み時間、レンダリングパフォーマンス
- **カバレッジ目標**: 主要なページと重要なユーザーパス
- **ツール**: Lighthouse、WebPageTest、k6
- **ベストプラクティス**:
- Core Web Vitalsの測定
- ローエンドデバイスでのテスト
- ネットワークスロットリングのシミュレーション
- バンドルサイズの監視
- 現実的なキャッシュシナリオでのテスト
- インタラクティブになるまでの時間測定
- パフォーマンスバジェットの設定

## テストプラクティス

### テストの構成

- 機能またはコンポーネントごとにテストを論理的にグループ化する
- 説明的なファイル名を使用してテストする説明
- テストユーティリティとフィクスチャを分離する
- コードベースを反映した階層構造でテストを整理する
- テストファイルはテスト対象のコードの近くに保管する
- 一貫した命名規則を使用する
- 単体テスト、統合テスト、E2Eテストを分離する

### テストデータ管理

- テストデータにはファクトリまたはビルダーを使用する
- ハードコードされたテストデータを避ける
- 本番環境のパターンに一致する現実的なデータを使用する
- テスト間でテスト状態をリセットする
- テスト環境を分離する
- テストデータのデータプライバシーを考慮する
- エッジケースにはシードされたランダムデータを使用する

### モックとスタブ

- 外部依存関係（API、サービス）をモックする
- 現実的なモックレスポンスを使用する
- テスト間でモックをリセットする
- 過剰なモックを避ける
- 適切なレベルでモックする
- モックの動作をドキュメント化する
- APIモックにはMSWを使用する

### 継続的インテグレーション

- すべてのプルリクエストでテストを実行する
- 並列テスト実行を実装する
-テストレポートとダッシュボードの設定
- テスト失敗通知の設定
- 不安定なテストに対するテスト再試行の実装
- テスト依存関係のキャッシュ
- 適切な段階で異なる種類のテストを実行する

## テスト駆動開発 (TDD)

- 機能を実装する前にテストを作成する
- レッド・グリーン・リファクタリング・サイクルに従う
- シンプルなテストケースから始める
- 段階的に複雑さを追加する
- テストを活用して設計を推進する
- コードの進化に合わせてテストをリファクタリングする
- 実装ではなく動作に焦点を当てる

## テストのメンテナンス

- 定期的にテストをレビューおよび更新する
- 不安定なテストを削除または修正する
- コード変更に合わせてテストをリファクタリングする
- テストのパフォーマンスを監視する
- テストカバレッジを定期的に分析する
- テスト戦略を文書化する
- チームメンバーにテストプラクティスをトレーニングする

## 特殊テスト

### API テスト

- すべての API エンドポイントをテストする
- リクエスト/レスポンススキーマを検証する
- 認証と認可をテストする
- エラー処理とステータスコードをテストする
-ビジネスロジックの検証
- レート制限とクォータのテスト
- APIテストケースのドキュメント化

### 状態管理テスト

- 状態遷移のテスト
- 初期状態の検証
- リデューサーとアクションのテスト
- セレクターと派生状態のテスト
- 外部依存関係のモック作成
- 非同期状態変更のテスト
- 状態の永続性の検証

### フォームテスト

- フォーム送信のテスト
- フォーム入力の検証
- エラー状態のテスト
- フォームリセット機能のテスト
- 条件付きフォームロジックのテスト
- フォーム要素のアクセシビリティの検証
- キーボードナビゲーションによるフォームのテスト

### セキュリティテスト

- 認証フローのテスト
- 認可チェックの検証
- 一般的な脆弱性（XSS、CSRF）のテスト
- 入力のサニタイズの検証
- ファイルアップロードのセキュリティのテスト
- セキュアヘッダーの検証
- OWASP Top 10のテスト