# Стандарти якості коду

## Основні принципи

- Пишіть чистий, зручний у підтримці та самодокументований код
- Дотримуйтесь принципів SOLID та DRY
- Зберігайте функції невеликими та сфокусованими (єдина відповідальність)
- Використовуйте описові імена для змінних, функцій та класів
- Підтримуйте узгоджений стиль коду в усьому проекті
- Документуйте складну логіку та публічні API
- Пишіть код для людей, а не лише для машин

## Стандарти JavaScript/TypeScript

### Конфігурація TypeScript

- Використовуйте суворий режим (`"strict": true`)
- Увімкніть усі рекомендовані параметри перевірки типів
- Налаштуйте правильну роздільну здатність модуля
- Встановіть відповідну цільову версію ECMAScript
- Вкажіть шаблони включення/виключення
- Використовуйте псевдоніми шляхів для чистішого імпорту

### Правила іменування

- **Змінні/Функції**: camelCase (`getUserData`, `calculateTotal`)
- **Класи/Інтерфейси/Типи**: PascalCase (`UserProfile`, `ApiResponse`)
- **Константи**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`, `API_URL`)
- **Приватні властивості**: Використовуйте префікс `#` або конвенцію `_` (`#privateField`, `_privateMethod`)
- **Логічні змінні**: Використовуйте префікси "is", "has", "can" (`isActive`, `hasPermission`)
- **Файли компонентів**: PascalCase з розширенням (`UserCard.tsx`)
- **Допоміжні файли**: camelCase з розширенням (`formatDate.ts`)

### Організація коду

- Один клас/компонент на файл
- Групування імпорту за зовнішніми/внутрішніми елементами
- Упорядкування імпорту в алфавітному порядку
- Використовування експорту типу "barrel" (`index.ts`) для пов'язаної функціональності
- Упорядкування коду за функціями/модулями
- Зберігання файлів до 400 рядків (розділення, якщо більші)
- Збереження функцій менше 50 рядків
- Максимальна вкладеність: 3-4 рівні глибини

### Найкращі практики

- Надавайте перевагу незмінності (const, readonly, Object.freeze)
- Використовуйте необов'язкове ланцюжування та об'єднання nullish
- Реалізуйте належну обробку помилок
- Уникайте будь-яких типів, окрім випадків необхідності
- Використовуйте захист типів для перевірки типів під час виконання
- Надавайте перевагу async/await над сирими обіцянками
- Уникайте магічних чисел та рядків (використовуйте константи)
- Реалізуйте належні перевірки null/undefined
- Використовуйте ранні повернення для зменшення вкладеності

## Стандарти React

### Структура компонентів

- Надавайте перевагу функціональним компонентам з перехоплювачами
- Використовуйте іменований експорт для компонентів
- Реалізуйте перевірку властивостей за допомогою TypeScript
- Витягуйте складну логіку до користувацьких перехоплювачів
- Зосереджуйте компоненти на проблемах інтерфейсу користувача
- Реалізуйте належні межі помилок
- Використовуйте React.memo для оптимізації продуктивності
- Витягуйте компоненти, що підлягають повторному використанню

### Керування станом

- Використовуйте локальний стан для даних, специфічних для компонентів
- Використовуйте контекст для спільного стану компоненти
- Розгляньте зовнішнє керування станом для складних додатків
- Зберігайте стан нормалізованим та мінімальним
- Реалізуйте належну ініціалізацію стану
- Використовуйте редуктори для складної логіки станів
- Уникайте дрилінгу проп (використовуйте композицію або контекст)

### Оптимізація продуктивності

- Використовуйте React.memo для чистих компонентів
- Реалізуйте useMemo для ресурсоємних обчислень
- Використовуйте useCallback для мемоізації функцій
- Віртуалізуйте довгі списки (react-window, react-virtualized)
- Реалізуйте належні масиви залежностей у хуках
- Уникайте непотрібних повторних рендерів
- Використовуйте React Profiler для виявлення вузьких місць

## Стандарти тестування

### Модульне тестування

- Тестуйте всю бізнес-логіку та утиліти
- Використовуйте Jest або Vitest як виконавець тестів
- Реалізуйте належне мокінгування залежностей
- Використовуйте бібліотеку тестування для тестування компонентів
- Дотримуйтесь шаблону AAA (Arrange, Act, Assert)
- Пишіть описові назви тестів
- Прагніть до >80% покриття коду
- Тестуйте граничні випадки та сценарії помилок

### Інтеграція Тестування

- Тестування взаємодії компонентів
- Тестування надсилання форм та потоків користувачів
- Використання MSW для імітації API
- Тестування маршрутизації та навігації
- Перевірка змін стану
- Тестування з реалістичними даними

### Комплексне тестування

- Використання Cypress або Playwright
- Тестування критичних шляхів користувачів
- Тестування на кількох браузерах
- Реалізація належної ізоляції тестів
- Використання атрибутів даних для селекторів тестів
- Реалізація логіки повторних спроб для нестабільних тестів
- Тестування доступності

## Стандарти перевірки коду

### Процес

- Весь код має бути перевірений перед об'єднанням
- Автоматизовані перевірки повинні пройти перевірку перед перевіркою
- Використання шаблонів запитів на втягування
- Зберігайте невеликі та цілеспрямовані PR
- Оперативно реагуйте на коментарі до перевірки
- Вирішуйте всі коментарі перед об'єднанням
- Стисніть коміти перед об'єднанням

### Контрольний список перевірки

- Код відповідає стандартам проекту
- Тести включені та проходять перевірку
- Документація оновлена
- Відсутність вразливостей безпеки
- Враховуються наслідки для продуктивності
- Вимоги до доступності зустрічається
- Обробка граничних випадків
- Відсутність зайвого коду чи залежностей

## Інструменти

### Лінтинг та форматування

- ESLint з відповідними правилами
- Гарніший для послідовного форматування
- Husky для перехоплень перед комітом
- lint-staged для інкрементального лінтингу
- Компілятор TypeScript для перевірки типів
- Stylelint для CSS/SCSS

### Статичний аналіз

- SonarQube або CodeClimate
- Моніторинг метрик складності
- Виявлення дублікатів коду
- Сканування вразливостей безпеки
- Аналіз розміру пакета
- Виявлення невикористаного коду

### Інтеграція CI/CD

- Виконання всіх перевірок для кожного PR
- Злиття блоків, якщо перевірки не проходять
- Генерація та публікація звітів про охоплення тестами
- Реалізація регресійного тестування продуктивності
- Автоматизація оновлень залежностей
- Розгортання середовищ попереднього перегляду